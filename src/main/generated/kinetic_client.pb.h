// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kinetic_client.proto

#ifndef PROTOBUF_kinetic_5fclient_2eproto__INCLUDED
#define PROTOBUF_kinetic_5fclient_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace seagate {
namespace kinetic {
namespace client {
namespace proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_kinetic_5fclient_2eproto();
void protobuf_AssignDesc_kinetic_5fclient_2eproto();
void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

class Local;
class Message;
class Message_HMACauth;
class Message_PINauth;
class Command;
class Command_Header;
class Command_Body;
class Command_Batch;
class Command_Status;
class Command_KeyValue;
class Command_Range;
class Command_Setup;
class Command_P2POperation;
class Command_P2POperation_Operation;
class Command_P2POperation_Peer;
class Command_GetLog;
class Command_GetLog_Utilization;
class Command_GetLog_Temperature;
class Command_GetLog_Capacity;
class Command_GetLog_Configuration;
class Command_GetLog_Configuration_Interface;
class Command_GetLog_Statistics;
class Command_GetLog_Limits;
class Command_GetLog_Device;
class Command_Security;
class Command_Security_ACL;
class Command_Security_ACL_Scope;
class Command_PinOperation;

enum Message_AuthType {
  Message_AuthType_INVALID_AUTH_TYPE = -1,
  Message_AuthType_HMACAUTH = 1,
  Message_AuthType_PINAUTH = 2,
  Message_AuthType_UNSOLICITEDSTATUS = 3
};
bool Message_AuthType_IsValid(int value);
const Message_AuthType Message_AuthType_AuthType_MIN = Message_AuthType_INVALID_AUTH_TYPE;
const Message_AuthType Message_AuthType_AuthType_MAX = Message_AuthType_UNSOLICITEDSTATUS;
const int Message_AuthType_AuthType_ARRAYSIZE = Message_AuthType_AuthType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_AuthType_descriptor();
inline const ::std::string& Message_AuthType_Name(Message_AuthType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_AuthType_descriptor(), value);
}
inline bool Message_AuthType_Parse(
    const ::std::string& name, Message_AuthType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_AuthType>(
    Message_AuthType_descriptor(), name, value);
}
enum Command_Status_StatusCode {
  Command_Status_StatusCode_INVALID_STATUS_CODE = -1,
  Command_Status_StatusCode_NOT_ATTEMPTED = 0,
  Command_Status_StatusCode_SUCCESS = 1,
  Command_Status_StatusCode_HMAC_FAILURE = 2,
  Command_Status_StatusCode_NOT_AUTHORIZED = 3,
  Command_Status_StatusCode_VERSION_FAILURE = 4,
  Command_Status_StatusCode_INTERNAL_ERROR = 5,
  Command_Status_StatusCode_HEADER_REQUIRED = 6,
  Command_Status_StatusCode_NOT_FOUND = 7,
  Command_Status_StatusCode_VERSION_MISMATCH = 8,
  Command_Status_StatusCode_SERVICE_BUSY = 9,
  Command_Status_StatusCode_EXPIRED = 10,
  Command_Status_StatusCode_DATA_ERROR = 11,
  Command_Status_StatusCode_PERM_DATA_ERROR = 12,
  Command_Status_StatusCode_REMOTE_CONNECTION_ERROR = 13,
  Command_Status_StatusCode_NO_SPACE = 14,
  Command_Status_StatusCode_NO_SUCH_HMAC_ALGORITHM = 15,
  Command_Status_StatusCode_INVALID_REQUEST = 16,
  Command_Status_StatusCode_NESTED_OPERATION_ERRORS = 17,
  Command_Status_StatusCode_DEVICE_LOCKED = 18,
  Command_Status_StatusCode_DEVICE_ALREADY_UNLOCKED = 19,
  Command_Status_StatusCode_CONNECTION_TERMINATED = 20,
  Command_Status_StatusCode_INVALID_BATCH = 21
};
bool Command_Status_StatusCode_IsValid(int value);
const Command_Status_StatusCode Command_Status_StatusCode_StatusCode_MIN = Command_Status_StatusCode_INVALID_STATUS_CODE;
const Command_Status_StatusCode Command_Status_StatusCode_StatusCode_MAX = Command_Status_StatusCode_INVALID_BATCH;
const int Command_Status_StatusCode_StatusCode_ARRAYSIZE = Command_Status_StatusCode_StatusCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Status_StatusCode_descriptor();
inline const ::std::string& Command_Status_StatusCode_Name(Command_Status_StatusCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Status_StatusCode_descriptor(), value);
}
inline bool Command_Status_StatusCode_Parse(
    const ::std::string& name, Command_Status_StatusCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Status_StatusCode>(
    Command_Status_StatusCode_descriptor(), name, value);
}
enum Command_GetLog_Type {
  Command_GetLog_Type_INVALID_TYPE = -1,
  Command_GetLog_Type_UTILIZATIONS = 0,
  Command_GetLog_Type_TEMPERATURES = 1,
  Command_GetLog_Type_CAPACITIES = 2,
  Command_GetLog_Type_CONFIGURATION = 3,
  Command_GetLog_Type_STATISTICS = 4,
  Command_GetLog_Type_MESSAGES = 5,
  Command_GetLog_Type_LIMITS = 6,
  Command_GetLog_Type_DEVICE = 7
};
bool Command_GetLog_Type_IsValid(int value);
const Command_GetLog_Type Command_GetLog_Type_Type_MIN = Command_GetLog_Type_INVALID_TYPE;
const Command_GetLog_Type Command_GetLog_Type_Type_MAX = Command_GetLog_Type_DEVICE;
const int Command_GetLog_Type_Type_ARRAYSIZE = Command_GetLog_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_GetLog_Type_descriptor();
inline const ::std::string& Command_GetLog_Type_Name(Command_GetLog_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_GetLog_Type_descriptor(), value);
}
inline bool Command_GetLog_Type_Parse(
    const ::std::string& name, Command_GetLog_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_GetLog_Type>(
    Command_GetLog_Type_descriptor(), name, value);
}
enum Command_Security_ACL_HMACAlgorithm {
  Command_Security_ACL_HMACAlgorithm_INVALID_HMAC_ALGORITHM = -1,
  Command_Security_ACL_HMACAlgorithm_HmacSHA1 = 1
};
bool Command_Security_ACL_HMACAlgorithm_IsValid(int value);
const Command_Security_ACL_HMACAlgorithm Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_MIN = Command_Security_ACL_HMACAlgorithm_INVALID_HMAC_ALGORITHM;
const Command_Security_ACL_HMACAlgorithm Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_MAX = Command_Security_ACL_HMACAlgorithm_HmacSHA1;
const int Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_ARRAYSIZE = Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Security_ACL_HMACAlgorithm_descriptor();
inline const ::std::string& Command_Security_ACL_HMACAlgorithm_Name(Command_Security_ACL_HMACAlgorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Security_ACL_HMACAlgorithm_descriptor(), value);
}
inline bool Command_Security_ACL_HMACAlgorithm_Parse(
    const ::std::string& name, Command_Security_ACL_HMACAlgorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Security_ACL_HMACAlgorithm>(
    Command_Security_ACL_HMACAlgorithm_descriptor(), name, value);
}
enum Command_Security_ACL_Permission {
  Command_Security_ACL_Permission_INVALID_PERMISSION = -1,
  Command_Security_ACL_Permission_READ = 0,
  Command_Security_ACL_Permission_WRITE = 1,
  Command_Security_ACL_Permission_DELETE = 2,
  Command_Security_ACL_Permission_RANGE = 3,
  Command_Security_ACL_Permission_SETUP = 4,
  Command_Security_ACL_Permission_P2POP = 5,
  Command_Security_ACL_Permission_GETLOG = 7,
  Command_Security_ACL_Permission_SECURITY = 8
};
bool Command_Security_ACL_Permission_IsValid(int value);
const Command_Security_ACL_Permission Command_Security_ACL_Permission_Permission_MIN = Command_Security_ACL_Permission_INVALID_PERMISSION;
const Command_Security_ACL_Permission Command_Security_ACL_Permission_Permission_MAX = Command_Security_ACL_Permission_SECURITY;
const int Command_Security_ACL_Permission_Permission_ARRAYSIZE = Command_Security_ACL_Permission_Permission_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Security_ACL_Permission_descriptor();
inline const ::std::string& Command_Security_ACL_Permission_Name(Command_Security_ACL_Permission value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Security_ACL_Permission_descriptor(), value);
}
inline bool Command_Security_ACL_Permission_Parse(
    const ::std::string& name, Command_Security_ACL_Permission* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Security_ACL_Permission>(
    Command_Security_ACL_Permission_descriptor(), name, value);
}
enum Command_PinOperation_PinOpType {
  Command_PinOperation_PinOpType_INVALID_PINOP = -1,
  Command_PinOperation_PinOpType_UNLOCK_PINOP = 1,
  Command_PinOperation_PinOpType_LOCK_PINOP = 2,
  Command_PinOperation_PinOpType_ERASE_PINOP = 3,
  Command_PinOperation_PinOpType_SECURE_ERASE_PINOP = 4
};
bool Command_PinOperation_PinOpType_IsValid(int value);
const Command_PinOperation_PinOpType Command_PinOperation_PinOpType_PinOpType_MIN = Command_PinOperation_PinOpType_INVALID_PINOP;
const Command_PinOperation_PinOpType Command_PinOperation_PinOpType_PinOpType_MAX = Command_PinOperation_PinOpType_SECURE_ERASE_PINOP;
const int Command_PinOperation_PinOpType_PinOpType_ARRAYSIZE = Command_PinOperation_PinOpType_PinOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_PinOperation_PinOpType_descriptor();
inline const ::std::string& Command_PinOperation_PinOpType_Name(Command_PinOperation_PinOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_PinOperation_PinOpType_descriptor(), value);
}
inline bool Command_PinOperation_PinOpType_Parse(
    const ::std::string& name, Command_PinOperation_PinOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_PinOperation_PinOpType>(
    Command_PinOperation_PinOpType_descriptor(), name, value);
}
enum Command_Synchronization {
  Command_Synchronization_INVALID_SYNCHRONIZATION = -1,
  Command_Synchronization_WRITETHROUGH = 1,
  Command_Synchronization_WRITEBACK = 2,
  Command_Synchronization_FLUSH = 3
};
bool Command_Synchronization_IsValid(int value);
const Command_Synchronization Command_Synchronization_Synchronization_MIN = Command_Synchronization_INVALID_SYNCHRONIZATION;
const Command_Synchronization Command_Synchronization_Synchronization_MAX = Command_Synchronization_FLUSH;
const int Command_Synchronization_Synchronization_ARRAYSIZE = Command_Synchronization_Synchronization_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Synchronization_descriptor();
inline const ::std::string& Command_Synchronization_Name(Command_Synchronization value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Synchronization_descriptor(), value);
}
inline bool Command_Synchronization_Parse(
    const ::std::string& name, Command_Synchronization* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Synchronization>(
    Command_Synchronization_descriptor(), name, value);
}
enum Command_Priority {
  Command_Priority_NORMAL = 5,
  Command_Priority_LOWEST = 1,
  Command_Priority_LOWER = 3,
  Command_Priority_HIGHER = 7,
  Command_Priority_HIGHEST = 9
};
bool Command_Priority_IsValid(int value);
const Command_Priority Command_Priority_Priority_MIN = Command_Priority_LOWEST;
const Command_Priority Command_Priority_Priority_MAX = Command_Priority_HIGHEST;
const int Command_Priority_Priority_ARRAYSIZE = Command_Priority_Priority_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Priority_descriptor();
inline const ::std::string& Command_Priority_Name(Command_Priority value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Priority_descriptor(), value);
}
inline bool Command_Priority_Parse(
    const ::std::string& name, Command_Priority* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Priority>(
    Command_Priority_descriptor(), name, value);
}
enum Command_Algorithm {
  Command_Algorithm_INVALID_ALGORITHM = -1,
  Command_Algorithm_SHA1 = 1,
  Command_Algorithm_SHA2 = 2,
  Command_Algorithm_SHA3 = 3,
  Command_Algorithm_CRC32 = 4,
  Command_Algorithm_CRC64 = 5
};
bool Command_Algorithm_IsValid(int value);
const Command_Algorithm Command_Algorithm_Algorithm_MIN = Command_Algorithm_INVALID_ALGORITHM;
const Command_Algorithm Command_Algorithm_Algorithm_MAX = Command_Algorithm_CRC64;
const int Command_Algorithm_Algorithm_ARRAYSIZE = Command_Algorithm_Algorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_Algorithm_descriptor();
inline const ::std::string& Command_Algorithm_Name(Command_Algorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_Algorithm_descriptor(), value);
}
inline bool Command_Algorithm_Parse(
    const ::std::string& name, Command_Algorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_Algorithm>(
    Command_Algorithm_descriptor(), name, value);
}
enum Command_MessageType {
  Command_MessageType_INVALID_MESSAGE_TYPE = -1,
  Command_MessageType_GET = 2,
  Command_MessageType_GET_RESPONSE = 1,
  Command_MessageType_PUT = 4,
  Command_MessageType_PUT_RESPONSE = 3,
  Command_MessageType_DELETE = 6,
  Command_MessageType_DELETE_RESPONSE = 5,
  Command_MessageType_GETNEXT = 8,
  Command_MessageType_GETNEXT_RESPONSE = 7,
  Command_MessageType_GETPREVIOUS = 10,
  Command_MessageType_GETPREVIOUS_RESPONSE = 9,
  Command_MessageType_GETKEYRANGE = 12,
  Command_MessageType_GETKEYRANGE_RESPONSE = 11,
  Command_MessageType_GETVERSION = 16,
  Command_MessageType_GETVERSION_RESPONSE = 15,
  Command_MessageType_SETUP = 22,
  Command_MessageType_SETUP_RESPONSE = 21,
  Command_MessageType_GETLOG = 24,
  Command_MessageType_GETLOG_RESPONSE = 23,
  Command_MessageType_SECURITY = 26,
  Command_MessageType_SECURITY_RESPONSE = 25,
  Command_MessageType_PEER2PEERPUSH = 28,
  Command_MessageType_PEER2PEERPUSH_RESPONSE = 27,
  Command_MessageType_NOOP = 30,
  Command_MessageType_NOOP_RESPONSE = 29,
  Command_MessageType_FLUSHALLDATA = 32,
  Command_MessageType_FLUSHALLDATA_RESPONSE = 31,
  Command_MessageType_PINOP = 36,
  Command_MessageType_PINOP_RESPONSE = 35,
  Command_MessageType_MEDIASCAN = 38,
  Command_MessageType_MEDIASCAN_RESPONSE = 37,
  Command_MessageType_MEDIAOPTIMIZE = 40,
  Command_MessageType_MEDIAOPTIMIZE_RESPONSE = 39,
  Command_MessageType_START_BATCH = 42,
  Command_MessageType_START_BATCH_RESPONSE = 41,
  Command_MessageType_END_BATCH = 44,
  Command_MessageType_END_BATCH_RESPONSE = 43,
  Command_MessageType_ABORT_BATCH = 46,
  Command_MessageType_ABORT_BATCH_RESPONSE = 45
};
bool Command_MessageType_IsValid(int value);
const Command_MessageType Command_MessageType_MessageType_MIN = Command_MessageType_INVALID_MESSAGE_TYPE;
const Command_MessageType Command_MessageType_MessageType_MAX = Command_MessageType_ABORT_BATCH;
const int Command_MessageType_MessageType_ARRAYSIZE = Command_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_MessageType_descriptor();
inline const ::std::string& Command_MessageType_Name(Command_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_MessageType_descriptor(), value);
}
inline bool Command_MessageType_Parse(
    const ::std::string& name, Command_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_MessageType>(
    Command_MessageType_descriptor(), name, value);
}
// ===================================================================

class Local : public ::google::protobuf::Message {
 public:
  Local();
  virtual ~Local();

  Local(const Local& from);

  inline Local& operator=(const Local& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Local& default_instance();

  void Swap(Local* other);

  // implements Message ----------------------------------------------

  Local* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Local& from);
  void MergeFrom(const Local& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string protocolVersion = 1 [default = "3.0.6"];
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 1;
  inline const ::std::string& protocolversion() const;
  inline void set_protocolversion(const ::std::string& value);
  inline void set_protocolversion(const char* value);
  inline void set_protocolversion(const char* value, size_t size);
  inline ::std::string* mutable_protocolversion();
  inline ::std::string* release_protocolversion();
  inline void set_allocated_protocolversion(::std::string* protocolversion);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Local)
 private:
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* protocolversion_;
  static ::std::string* _default_protocolversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Local* default_instance_;
};
// -------------------------------------------------------------------

class Message_HMACauth : public ::google::protobuf::Message {
 public:
  Message_HMACauth();
  virtual ~Message_HMACauth();

  Message_HMACauth(const Message_HMACauth& from);

  inline Message_HMACauth& operator=(const Message_HMACauth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_HMACauth& default_instance();

  void Swap(Message_HMACauth* other);

  // implements Message ----------------------------------------------

  Message_HMACauth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_HMACauth& from);
  void MergeFrom(const Message_HMACauth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 identity = 1;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 1;
  inline ::google::protobuf::int64 identity() const;
  inline void set_identity(::google::protobuf::int64 value);

  // optional bytes hmac = 2;
  inline bool has_hmac() const;
  inline void clear_hmac();
  static const int kHmacFieldNumber = 2;
  inline const ::std::string& hmac() const;
  inline void set_hmac(const ::std::string& value);
  inline void set_hmac(const char* value);
  inline void set_hmac(const void* value, size_t size);
  inline ::std::string* mutable_hmac();
  inline ::std::string* release_hmac();
  inline void set_allocated_hmac(::std::string* hmac);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Message.HMACauth)
 private:
  inline void set_has_identity();
  inline void clear_has_identity();
  inline void set_has_hmac();
  inline void clear_has_hmac();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 identity_;
  ::std::string* hmac_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Message_HMACauth* default_instance_;
};
// -------------------------------------------------------------------

class Message_PINauth : public ::google::protobuf::Message {
 public:
  Message_PINauth();
  virtual ~Message_PINauth();

  Message_PINauth(const Message_PINauth& from);

  inline Message_PINauth& operator=(const Message_PINauth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message_PINauth& default_instance();

  void Swap(Message_PINauth* other);

  // implements Message ----------------------------------------------

  Message_PINauth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message_PINauth& from);
  void MergeFrom(const Message_PINauth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes pin = 1;
  inline bool has_pin() const;
  inline void clear_pin();
  static const int kPinFieldNumber = 1;
  inline const ::std::string& pin() const;
  inline void set_pin(const ::std::string& value);
  inline void set_pin(const char* value);
  inline void set_pin(const void* value, size_t size);
  inline ::std::string* mutable_pin();
  inline ::std::string* release_pin();
  inline void set_allocated_pin(::std::string* pin);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Message.PINauth)
 private:
  inline void set_has_pin();
  inline void clear_has_pin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Message_PINauth* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_HMACauth HMACauth;
  typedef Message_PINauth PINauth;

  typedef Message_AuthType AuthType;
  static const AuthType INVALID_AUTH_TYPE = Message_AuthType_INVALID_AUTH_TYPE;
  static const AuthType HMACAUTH = Message_AuthType_HMACAUTH;
  static const AuthType PINAUTH = Message_AuthType_PINAUTH;
  static const AuthType UNSOLICITEDSTATUS = Message_AuthType_UNSOLICITEDSTATUS;
  static inline bool AuthType_IsValid(int value) {
    return Message_AuthType_IsValid(value);
  }
  static const AuthType AuthType_MIN =
    Message_AuthType_AuthType_MIN;
  static const AuthType AuthType_MAX =
    Message_AuthType_AuthType_MAX;
  static const int AuthType_ARRAYSIZE =
    Message_AuthType_AuthType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AuthType_descriptor() {
    return Message_AuthType_descriptor();
  }
  static inline const ::std::string& AuthType_Name(AuthType value) {
    return Message_AuthType_Name(value);
  }
  static inline bool AuthType_Parse(const ::std::string& name,
      AuthType* value) {
    return Message_AuthType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Message.AuthType authType = 4;
  inline bool has_authtype() const;
  inline void clear_authtype();
  static const int kAuthTypeFieldNumber = 4;
  inline ::com::seagate::kinetic::client::proto::Message_AuthType authtype() const;
  inline void set_authtype(::com::seagate::kinetic::client::proto::Message_AuthType value);

  // optional .com.seagate.kinetic.client.proto.Message.HMACauth hmacAuth = 5;
  inline bool has_hmacauth() const;
  inline void clear_hmacauth();
  static const int kHmacAuthFieldNumber = 5;
  inline const ::com::seagate::kinetic::client::proto::Message_HMACauth& hmacauth() const;
  inline ::com::seagate::kinetic::client::proto::Message_HMACauth* mutable_hmacauth();
  inline ::com::seagate::kinetic::client::proto::Message_HMACauth* release_hmacauth();
  inline void set_allocated_hmacauth(::com::seagate::kinetic::client::proto::Message_HMACauth* hmacauth);

  // optional .com.seagate.kinetic.client.proto.Message.PINauth pinAuth = 6;
  inline bool has_pinauth() const;
  inline void clear_pinauth();
  static const int kPinAuthFieldNumber = 6;
  inline const ::com::seagate::kinetic::client::proto::Message_PINauth& pinauth() const;
  inline ::com::seagate::kinetic::client::proto::Message_PINauth* mutable_pinauth();
  inline ::com::seagate::kinetic::client::proto::Message_PINauth* release_pinauth();
  inline void set_allocated_pinauth(::com::seagate::kinetic::client::proto::Message_PINauth* pinauth);

  // optional bytes commandBytes = 7;
  inline bool has_commandbytes() const;
  inline void clear_commandbytes();
  static const int kCommandBytesFieldNumber = 7;
  inline const ::std::string& commandbytes() const;
  inline void set_commandbytes(const ::std::string& value);
  inline void set_commandbytes(const char* value);
  inline void set_commandbytes(const void* value, size_t size);
  inline ::std::string* mutable_commandbytes();
  inline ::std::string* release_commandbytes();
  inline void set_allocated_commandbytes(::std::string* commandbytes);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Message)
 private:
  inline void set_has_authtype();
  inline void clear_has_authtype();
  inline void set_has_hmacauth();
  inline void clear_has_hmacauth();
  inline void set_has_pinauth();
  inline void clear_has_pinauth();
  inline void set_has_commandbytes();
  inline void clear_has_commandbytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::seagate::kinetic::client::proto::Message_HMACauth* hmacauth_;
  ::com::seagate::kinetic::client::proto::Message_PINauth* pinauth_;
  ::std::string* commandbytes_;
  int authtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// -------------------------------------------------------------------

class Command_Header : public ::google::protobuf::Message {
 public:
  Command_Header();
  virtual ~Command_Header();

  Command_Header(const Command_Header& from);

  inline Command_Header& operator=(const Command_Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Header& default_instance();

  void Swap(Command_Header* other);

  // implements Message ----------------------------------------------

  Command_Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Header& from);
  void MergeFrom(const Command_Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 clusterVersion = 1;
  inline bool has_clusterversion() const;
  inline void clear_clusterversion();
  static const int kClusterVersionFieldNumber = 1;
  inline ::google::protobuf::int64 clusterversion() const;
  inline void set_clusterversion(::google::protobuf::int64 value);

  // optional int64 connectionID = 3;
  inline bool has_connectionid() const;
  inline void clear_connectionid();
  static const int kConnectionIDFieldNumber = 3;
  inline ::google::protobuf::int64 connectionid() const;
  inline void set_connectionid(::google::protobuf::int64 value);

  // optional int64 sequence = 4;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  inline ::google::protobuf::int64 sequence() const;
  inline void set_sequence(::google::protobuf::int64 value);

  // optional int64 ackSequence = 6;
  inline bool has_acksequence() const;
  inline void clear_acksequence();
  static const int kAckSequenceFieldNumber = 6;
  inline ::google::protobuf::int64 acksequence() const;
  inline void set_acksequence(::google::protobuf::int64 value);

  // optional .com.seagate.kinetic.client.proto.Command.MessageType messageType = 7;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 7;
  inline ::com::seagate::kinetic::client::proto::Command_MessageType messagetype() const;
  inline void set_messagetype(::com::seagate::kinetic::client::proto::Command_MessageType value);

  // optional int64 timeout = 9;
  inline bool has_timeout() const;
  inline void clear_timeout();
  static const int kTimeoutFieldNumber = 9;
  inline ::google::protobuf::int64 timeout() const;
  inline void set_timeout(::google::protobuf::int64 value);

  // optional bool earlyExit = 10;
  inline bool has_earlyexit() const;
  inline void clear_earlyexit();
  static const int kEarlyExitFieldNumber = 10;
  inline bool earlyexit() const;
  inline void set_earlyexit(bool value);

  // optional .com.seagate.kinetic.client.proto.Command.Priority priority = 12;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 12;
  inline ::com::seagate::kinetic::client::proto::Command_Priority priority() const;
  inline void set_priority(::com::seagate::kinetic::client::proto::Command_Priority value);

  // optional int64 TimeQuanta = 13;
  inline bool has_timequanta() const;
  inline void clear_timequanta();
  static const int kTimeQuantaFieldNumber = 13;
  inline ::google::protobuf::int64 timequanta() const;
  inline void set_timequanta(::google::protobuf::int64 value);

  // optional uint32 batchID = 14;
  inline bool has_batchid() const;
  inline void clear_batchid();
  static const int kBatchIDFieldNumber = 14;
  inline ::google::protobuf::uint32 batchid() const;
  inline void set_batchid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Header)
 private:
  inline void set_has_clusterversion();
  inline void clear_has_clusterversion();
  inline void set_has_connectionid();
  inline void clear_has_connectionid();
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_acksequence();
  inline void clear_has_acksequence();
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_timeout();
  inline void clear_has_timeout();
  inline void set_has_earlyexit();
  inline void clear_has_earlyexit();
  inline void set_has_priority();
  inline void clear_has_priority();
  inline void set_has_timequanta();
  inline void clear_has_timequanta();
  inline void set_has_batchid();
  inline void clear_has_batchid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 clusterversion_;
  ::google::protobuf::int64 connectionid_;
  ::google::protobuf::int64 sequence_;
  ::google::protobuf::int64 acksequence_;
  ::google::protobuf::int64 timeout_;
  int messagetype_;
  bool earlyexit_;
  ::google::protobuf::int64 timequanta_;
  int priority_;
  ::google::protobuf::uint32 batchid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Header* default_instance_;
};
// -------------------------------------------------------------------

class Command_Body : public ::google::protobuf::Message {
 public:
  Command_Body();
  virtual ~Command_Body();

  Command_Body(const Command_Body& from);

  inline Command_Body& operator=(const Command_Body& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Body& default_instance();

  void Swap(Command_Body* other);

  // implements Message ----------------------------------------------

  Command_Body* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Body& from);
  void MergeFrom(const Command_Body& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Command.KeyValue keyValue = 1;
  inline bool has_keyvalue() const;
  inline void clear_keyvalue();
  static const int kKeyValueFieldNumber = 1;
  inline const ::com::seagate::kinetic::client::proto::Command_KeyValue& keyvalue() const;
  inline ::com::seagate::kinetic::client::proto::Command_KeyValue* mutable_keyvalue();
  inline ::com::seagate::kinetic::client::proto::Command_KeyValue* release_keyvalue();
  inline void set_allocated_keyvalue(::com::seagate::kinetic::client::proto::Command_KeyValue* keyvalue);

  // optional .com.seagate.kinetic.client.proto.Command.Range range = 2;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 2;
  inline const ::com::seagate::kinetic::client::proto::Command_Range& range() const;
  inline ::com::seagate::kinetic::client::proto::Command_Range* mutable_range();
  inline ::com::seagate::kinetic::client::proto::Command_Range* release_range();
  inline void set_allocated_range(::com::seagate::kinetic::client::proto::Command_Range* range);

  // optional .com.seagate.kinetic.client.proto.Command.Setup setup = 3;
  inline bool has_setup() const;
  inline void clear_setup();
  static const int kSetupFieldNumber = 3;
  inline const ::com::seagate::kinetic::client::proto::Command_Setup& setup() const;
  inline ::com::seagate::kinetic::client::proto::Command_Setup* mutable_setup();
  inline ::com::seagate::kinetic::client::proto::Command_Setup* release_setup();
  inline void set_allocated_setup(::com::seagate::kinetic::client::proto::Command_Setup* setup);

  // optional .com.seagate.kinetic.client.proto.Command.P2POperation p2pOperation = 4;
  inline bool has_p2poperation() const;
  inline void clear_p2poperation();
  static const int kP2POperationFieldNumber = 4;
  inline const ::com::seagate::kinetic::client::proto::Command_P2POperation& p2poperation() const;
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation* mutable_p2poperation();
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation* release_p2poperation();
  inline void set_allocated_p2poperation(::com::seagate::kinetic::client::proto::Command_P2POperation* p2poperation);

  // optional .com.seagate.kinetic.client.proto.Command.GetLog getLog = 6;
  inline bool has_getlog() const;
  inline void clear_getlog();
  static const int kGetLogFieldNumber = 6;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog& getlog() const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog* mutable_getlog();
  inline ::com::seagate::kinetic::client::proto::Command_GetLog* release_getlog();
  inline void set_allocated_getlog(::com::seagate::kinetic::client::proto::Command_GetLog* getlog);

  // optional .com.seagate.kinetic.client.proto.Command.Security security = 7;
  inline bool has_security() const;
  inline void clear_security();
  static const int kSecurityFieldNumber = 7;
  inline const ::com::seagate::kinetic::client::proto::Command_Security& security() const;
  inline ::com::seagate::kinetic::client::proto::Command_Security* mutable_security();
  inline ::com::seagate::kinetic::client::proto::Command_Security* release_security();
  inline void set_allocated_security(::com::seagate::kinetic::client::proto::Command_Security* security);

  // optional .com.seagate.kinetic.client.proto.Command.PinOperation pinOp = 8;
  inline bool has_pinop() const;
  inline void clear_pinop();
  static const int kPinOpFieldNumber = 8;
  inline const ::com::seagate::kinetic::client::proto::Command_PinOperation& pinop() const;
  inline ::com::seagate::kinetic::client::proto::Command_PinOperation* mutable_pinop();
  inline ::com::seagate::kinetic::client::proto::Command_PinOperation* release_pinop();
  inline void set_allocated_pinop(::com::seagate::kinetic::client::proto::Command_PinOperation* pinop);

  // optional .com.seagate.kinetic.client.proto.Command.Batch batch = 9;
  inline bool has_batch() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 9;
  inline const ::com::seagate::kinetic::client::proto::Command_Batch& batch() const;
  inline ::com::seagate::kinetic::client::proto::Command_Batch* mutable_batch();
  inline ::com::seagate::kinetic::client::proto::Command_Batch* release_batch();
  inline void set_allocated_batch(::com::seagate::kinetic::client::proto::Command_Batch* batch);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Body)
 private:
  inline void set_has_keyvalue();
  inline void clear_has_keyvalue();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_setup();
  inline void clear_has_setup();
  inline void set_has_p2poperation();
  inline void clear_has_p2poperation();
  inline void set_has_getlog();
  inline void clear_has_getlog();
  inline void set_has_security();
  inline void clear_has_security();
  inline void set_has_pinop();
  inline void clear_has_pinop();
  inline void set_has_batch();
  inline void clear_has_batch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::seagate::kinetic::client::proto::Command_KeyValue* keyvalue_;
  ::com::seagate::kinetic::client::proto::Command_Range* range_;
  ::com::seagate::kinetic::client::proto::Command_Setup* setup_;
  ::com::seagate::kinetic::client::proto::Command_P2POperation* p2poperation_;
  ::com::seagate::kinetic::client::proto::Command_GetLog* getlog_;
  ::com::seagate::kinetic::client::proto::Command_Security* security_;
  ::com::seagate::kinetic::client::proto::Command_PinOperation* pinop_;
  ::com::seagate::kinetic::client::proto::Command_Batch* batch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Body* default_instance_;
};
// -------------------------------------------------------------------

class Command_Batch : public ::google::protobuf::Message {
 public:
  Command_Batch();
  virtual ~Command_Batch();

  Command_Batch(const Command_Batch& from);

  inline Command_Batch& operator=(const Command_Batch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Batch& default_instance();

  void Swap(Command_Batch* other);

  // implements Message ----------------------------------------------

  Command_Batch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Batch& from);
  void MergeFrom(const Command_Batch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // repeated int64 sequence = 2 [packed = true];
  inline int sequence_size() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  inline ::google::protobuf::int64 sequence(int index) const;
  inline void set_sequence(int index, ::google::protobuf::int64 value);
  inline void add_sequence(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      sequence() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_sequence();

  // optional int64 failedSequence = 3;
  inline bool has_failedsequence() const;
  inline void clear_failedsequence();
  static const int kFailedSequenceFieldNumber = 3;
  inline ::google::protobuf::int64 failedsequence() const;
  inline void set_failedsequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Batch)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_failedsequence();
  inline void clear_has_failedsequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > sequence_;
  mutable int _sequence_cached_byte_size_;
  ::google::protobuf::int64 failedsequence_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Batch* default_instance_;
};
// -------------------------------------------------------------------

class Command_Status : public ::google::protobuf::Message {
 public:
  Command_Status();
  virtual ~Command_Status();

  Command_Status(const Command_Status& from);

  inline Command_Status& operator=(const Command_Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Status& default_instance();

  void Swap(Command_Status* other);

  // implements Message ----------------------------------------------

  Command_Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Status& from);
  void MergeFrom(const Command_Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Status_StatusCode StatusCode;
  static const StatusCode INVALID_STATUS_CODE = Command_Status_StatusCode_INVALID_STATUS_CODE;
  static const StatusCode NOT_ATTEMPTED = Command_Status_StatusCode_NOT_ATTEMPTED;
  static const StatusCode SUCCESS = Command_Status_StatusCode_SUCCESS;
  static const StatusCode HMAC_FAILURE = Command_Status_StatusCode_HMAC_FAILURE;
  static const StatusCode NOT_AUTHORIZED = Command_Status_StatusCode_NOT_AUTHORIZED;
  static const StatusCode VERSION_FAILURE = Command_Status_StatusCode_VERSION_FAILURE;
  static const StatusCode INTERNAL_ERROR = Command_Status_StatusCode_INTERNAL_ERROR;
  static const StatusCode HEADER_REQUIRED = Command_Status_StatusCode_HEADER_REQUIRED;
  static const StatusCode NOT_FOUND = Command_Status_StatusCode_NOT_FOUND;
  static const StatusCode VERSION_MISMATCH = Command_Status_StatusCode_VERSION_MISMATCH;
  static const StatusCode SERVICE_BUSY = Command_Status_StatusCode_SERVICE_BUSY;
  static const StatusCode EXPIRED = Command_Status_StatusCode_EXPIRED;
  static const StatusCode DATA_ERROR = Command_Status_StatusCode_DATA_ERROR;
  static const StatusCode PERM_DATA_ERROR = Command_Status_StatusCode_PERM_DATA_ERROR;
  static const StatusCode REMOTE_CONNECTION_ERROR = Command_Status_StatusCode_REMOTE_CONNECTION_ERROR;
  static const StatusCode NO_SPACE = Command_Status_StatusCode_NO_SPACE;
  static const StatusCode NO_SUCH_HMAC_ALGORITHM = Command_Status_StatusCode_NO_SUCH_HMAC_ALGORITHM;
  static const StatusCode INVALID_REQUEST = Command_Status_StatusCode_INVALID_REQUEST;
  static const StatusCode NESTED_OPERATION_ERRORS = Command_Status_StatusCode_NESTED_OPERATION_ERRORS;
  static const StatusCode DEVICE_LOCKED = Command_Status_StatusCode_DEVICE_LOCKED;
  static const StatusCode DEVICE_ALREADY_UNLOCKED = Command_Status_StatusCode_DEVICE_ALREADY_UNLOCKED;
  static const StatusCode CONNECTION_TERMINATED = Command_Status_StatusCode_CONNECTION_TERMINATED;
  static const StatusCode INVALID_BATCH = Command_Status_StatusCode_INVALID_BATCH;
  static inline bool StatusCode_IsValid(int value) {
    return Command_Status_StatusCode_IsValid(value);
  }
  static const StatusCode StatusCode_MIN =
    Command_Status_StatusCode_StatusCode_MIN;
  static const StatusCode StatusCode_MAX =
    Command_Status_StatusCode_StatusCode_MAX;
  static const int StatusCode_ARRAYSIZE =
    Command_Status_StatusCode_StatusCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StatusCode_descriptor() {
    return Command_Status_StatusCode_descriptor();
  }
  static inline const ::std::string& StatusCode_Name(StatusCode value) {
    return Command_Status_StatusCode_Name(value);
  }
  static inline bool StatusCode_Parse(const ::std::string& name,
      StatusCode* value) {
    return Command_Status_StatusCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Command.Status.StatusCode code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::com::seagate::kinetic::client::proto::Command_Status_StatusCode code() const;
  inline void set_code(::com::seagate::kinetic::client::proto::Command_Status_StatusCode value);

  // optional string statusMessage = 2;
  inline bool has_statusmessage() const;
  inline void clear_statusmessage();
  static const int kStatusMessageFieldNumber = 2;
  inline const ::std::string& statusmessage() const;
  inline void set_statusmessage(const ::std::string& value);
  inline void set_statusmessage(const char* value);
  inline void set_statusmessage(const char* value, size_t size);
  inline ::std::string* mutable_statusmessage();
  inline ::std::string* release_statusmessage();
  inline void set_allocated_statusmessage(::std::string* statusmessage);

  // optional bytes detailedMessage = 3;
  inline bool has_detailedmessage() const;
  inline void clear_detailedmessage();
  static const int kDetailedMessageFieldNumber = 3;
  inline const ::std::string& detailedmessage() const;
  inline void set_detailedmessage(const ::std::string& value);
  inline void set_detailedmessage(const char* value);
  inline void set_detailedmessage(const void* value, size_t size);
  inline ::std::string* mutable_detailedmessage();
  inline ::std::string* release_detailedmessage();
  inline void set_allocated_detailedmessage(::std::string* detailedmessage);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Status)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_statusmessage();
  inline void clear_has_statusmessage();
  inline void set_has_detailedmessage();
  inline void clear_has_detailedmessage();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* statusmessage_;
  ::std::string* detailedmessage_;
  int code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Status* default_instance_;
};
// -------------------------------------------------------------------

class Command_KeyValue : public ::google::protobuf::Message {
 public:
  Command_KeyValue();
  virtual ~Command_KeyValue();

  Command_KeyValue(const Command_KeyValue& from);

  inline Command_KeyValue& operator=(const Command_KeyValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_KeyValue& default_instance();

  void Swap(Command_KeyValue* other);

  // implements Message ----------------------------------------------

  Command_KeyValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_KeyValue& from);
  void MergeFrom(const Command_KeyValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes newVersion = 2;
  inline bool has_newversion() const;
  inline void clear_newversion();
  static const int kNewVersionFieldNumber = 2;
  inline const ::std::string& newversion() const;
  inline void set_newversion(const ::std::string& value);
  inline void set_newversion(const char* value);
  inline void set_newversion(const void* value, size_t size);
  inline ::std::string* mutable_newversion();
  inline ::std::string* release_newversion();
  inline void set_allocated_newversion(::std::string* newversion);

  // optional bool force = 8;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 8;
  inline bool force() const;
  inline void set_force(bool value);

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes dbVersion = 4;
  inline bool has_dbversion() const;
  inline void clear_dbversion();
  static const int kDbVersionFieldNumber = 4;
  inline const ::std::string& dbversion() const;
  inline void set_dbversion(const ::std::string& value);
  inline void set_dbversion(const char* value);
  inline void set_dbversion(const void* value, size_t size);
  inline ::std::string* mutable_dbversion();
  inline ::std::string* release_dbversion();
  inline void set_allocated_dbversion(::std::string* dbversion);

  // optional bytes tag = 5;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 5;
  inline const ::std::string& tag() const;
  inline void set_tag(const ::std::string& value);
  inline void set_tag(const char* value);
  inline void set_tag(const void* value, size_t size);
  inline ::std::string* mutable_tag();
  inline ::std::string* release_tag();
  inline void set_allocated_tag(::std::string* tag);

  // optional .com.seagate.kinetic.client.proto.Command.Algorithm algorithm = 6;
  inline bool has_algorithm() const;
  inline void clear_algorithm();
  static const int kAlgorithmFieldNumber = 6;
  inline ::com::seagate::kinetic::client::proto::Command_Algorithm algorithm() const;
  inline void set_algorithm(::com::seagate::kinetic::client::proto::Command_Algorithm value);

  // optional bool metadataOnly = 7;
  inline bool has_metadataonly() const;
  inline void clear_metadataonly();
  static const int kMetadataOnlyFieldNumber = 7;
  inline bool metadataonly() const;
  inline void set_metadataonly(bool value);

  // optional .com.seagate.kinetic.client.proto.Command.Synchronization synchronization = 9;
  inline bool has_synchronization() const;
  inline void clear_synchronization();
  static const int kSynchronizationFieldNumber = 9;
  inline ::com::seagate::kinetic::client::proto::Command_Synchronization synchronization() const;
  inline void set_synchronization(::com::seagate::kinetic::client::proto::Command_Synchronization value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.KeyValue)
 private:
  inline void set_has_newversion();
  inline void clear_has_newversion();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_dbversion();
  inline void clear_has_dbversion();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_algorithm();
  inline void clear_has_algorithm();
  inline void set_has_metadataonly();
  inline void clear_has_metadataonly();
  inline void set_has_synchronization();
  inline void clear_has_synchronization();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* newversion_;
  ::std::string* key_;
  ::std::string* dbversion_;
  ::std::string* tag_;
  bool force_;
  bool metadataonly_;
  int algorithm_;
  int synchronization_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_KeyValue* default_instance_;
};
// -------------------------------------------------------------------

class Command_Range : public ::google::protobuf::Message {
 public:
  Command_Range();
  virtual ~Command_Range();

  Command_Range(const Command_Range& from);

  inline Command_Range& operator=(const Command_Range& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Range& default_instance();

  void Swap(Command_Range* other);

  // implements Message ----------------------------------------------

  Command_Range* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Range& from);
  void MergeFrom(const Command_Range& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes startKey = 1;
  inline bool has_startkey() const;
  inline void clear_startkey();
  static const int kStartKeyFieldNumber = 1;
  inline const ::std::string& startkey() const;
  inline void set_startkey(const ::std::string& value);
  inline void set_startkey(const char* value);
  inline void set_startkey(const void* value, size_t size);
  inline ::std::string* mutable_startkey();
  inline ::std::string* release_startkey();
  inline void set_allocated_startkey(::std::string* startkey);

  // optional bytes endKey = 2;
  inline bool has_endkey() const;
  inline void clear_endkey();
  static const int kEndKeyFieldNumber = 2;
  inline const ::std::string& endkey() const;
  inline void set_endkey(const ::std::string& value);
  inline void set_endkey(const char* value);
  inline void set_endkey(const void* value, size_t size);
  inline ::std::string* mutable_endkey();
  inline ::std::string* release_endkey();
  inline void set_allocated_endkey(::std::string* endkey);

  // optional bool startKeyInclusive = 3;
  inline bool has_startkeyinclusive() const;
  inline void clear_startkeyinclusive();
  static const int kStartKeyInclusiveFieldNumber = 3;
  inline bool startkeyinclusive() const;
  inline void set_startkeyinclusive(bool value);

  // optional bool endKeyInclusive = 4;
  inline bool has_endkeyinclusive() const;
  inline void clear_endkeyinclusive();
  static const int kEndKeyInclusiveFieldNumber = 4;
  inline bool endkeyinclusive() const;
  inline void set_endkeyinclusive(bool value);

  // optional int32 maxReturned = 5;
  inline bool has_maxreturned() const;
  inline void clear_maxreturned();
  static const int kMaxReturnedFieldNumber = 5;
  inline ::google::protobuf::int32 maxreturned() const;
  inline void set_maxreturned(::google::protobuf::int32 value);

  // optional bool reverse = 6;
  inline bool has_reverse() const;
  inline void clear_reverse();
  static const int kReverseFieldNumber = 6;
  inline bool reverse() const;
  inline void set_reverse(bool value);

  // repeated bytes keys = 8;
  inline int keys_size() const;
  inline void clear_keys();
  static const int kKeysFieldNumber = 8;
  inline const ::std::string& keys(int index) const;
  inline ::std::string* mutable_keys(int index);
  inline void set_keys(int index, const ::std::string& value);
  inline void set_keys(int index, const char* value);
  inline void set_keys(int index, const void* value, size_t size);
  inline ::std::string* add_keys();
  inline void add_keys(const ::std::string& value);
  inline void add_keys(const char* value);
  inline void add_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Range)
 private:
  inline void set_has_startkey();
  inline void clear_has_startkey();
  inline void set_has_endkey();
  inline void clear_has_endkey();
  inline void set_has_startkeyinclusive();
  inline void clear_has_startkeyinclusive();
  inline void set_has_endkeyinclusive();
  inline void clear_has_endkeyinclusive();
  inline void set_has_maxreturned();
  inline void clear_has_maxreturned();
  inline void set_has_reverse();
  inline void clear_has_reverse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* startkey_;
  ::std::string* endkey_;
  bool startkeyinclusive_;
  bool endkeyinclusive_;
  bool reverse_;
  ::google::protobuf::int32 maxreturned_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Range* default_instance_;
};
// -------------------------------------------------------------------

class Command_Setup : public ::google::protobuf::Message {
 public:
  Command_Setup();
  virtual ~Command_Setup();

  Command_Setup(const Command_Setup& from);

  inline Command_Setup& operator=(const Command_Setup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Setup& default_instance();

  void Swap(Command_Setup* other);

  // implements Message ----------------------------------------------

  Command_Setup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Setup& from);
  void MergeFrom(const Command_Setup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 newClusterVersion = 1;
  inline bool has_newclusterversion() const;
  inline void clear_newclusterversion();
  static const int kNewClusterVersionFieldNumber = 1;
  inline ::google::protobuf::int64 newclusterversion() const;
  inline void set_newclusterversion(::google::protobuf::int64 value);

  // optional bool firmwareDownload = 5;
  inline bool has_firmwaredownload() const;
  inline void clear_firmwaredownload();
  static const int kFirmwareDownloadFieldNumber = 5;
  inline bool firmwaredownload() const;
  inline void set_firmwaredownload(bool value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Setup)
 private:
  inline void set_has_newclusterversion();
  inline void clear_has_newclusterversion();
  inline void set_has_firmwaredownload();
  inline void clear_has_firmwaredownload();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 newclusterversion_;
  bool firmwaredownload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Setup* default_instance_;
};
// -------------------------------------------------------------------

class Command_P2POperation_Operation : public ::google::protobuf::Message {
 public:
  Command_P2POperation_Operation();
  virtual ~Command_P2POperation_Operation();

  Command_P2POperation_Operation(const Command_P2POperation_Operation& from);

  inline Command_P2POperation_Operation& operator=(const Command_P2POperation_Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_P2POperation_Operation& default_instance();

  void Swap(Command_P2POperation_Operation* other);

  // implements Message ----------------------------------------------

  Command_P2POperation_Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_P2POperation_Operation& from);
  void MergeFrom(const Command_P2POperation_Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const void* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional bytes newKey = 5;
  inline bool has_newkey() const;
  inline void clear_newkey();
  static const int kNewKeyFieldNumber = 5;
  inline const ::std::string& newkey() const;
  inline void set_newkey(const ::std::string& value);
  inline void set_newkey(const char* value);
  inline void set_newkey(const void* value, size_t size);
  inline ::std::string* mutable_newkey();
  inline ::std::string* release_newkey();
  inline void set_allocated_newkey(::std::string* newkey);

  // optional bool force = 6;
  inline bool has_force() const;
  inline void clear_force();
  static const int kForceFieldNumber = 6;
  inline bool force() const;
  inline void set_force(bool value);

  // optional .com.seagate.kinetic.client.proto.Command.Status status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline const ::com::seagate::kinetic::client::proto::Command_Status& status() const;
  inline ::com::seagate::kinetic::client::proto::Command_Status* mutable_status();
  inline ::com::seagate::kinetic::client::proto::Command_Status* release_status();
  inline void set_allocated_status(::com::seagate::kinetic::client::proto::Command_Status* status);

  // optional .com.seagate.kinetic.client.proto.Command.P2POperation p2pop = 8;
  inline bool has_p2pop() const;
  inline void clear_p2pop();
  static const int kP2PopFieldNumber = 8;
  inline const ::com::seagate::kinetic::client::proto::Command_P2POperation& p2pop() const;
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation* mutable_p2pop();
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation* release_p2pop();
  inline void set_allocated_p2pop(::com::seagate::kinetic::client::proto::Command_P2POperation* p2pop);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.P2POperation.Operation)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_newkey();
  inline void clear_has_newkey();
  inline void set_has_force();
  inline void clear_has_force();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_p2pop();
  inline void clear_has_p2pop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* version_;
  ::std::string* newkey_;
  ::com::seagate::kinetic::client::proto::Command_Status* status_;
  ::com::seagate::kinetic::client::proto::Command_P2POperation* p2pop_;
  bool force_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_P2POperation_Operation* default_instance_;
};
// -------------------------------------------------------------------

class Command_P2POperation_Peer : public ::google::protobuf::Message {
 public:
  Command_P2POperation_Peer();
  virtual ~Command_P2POperation_Peer();

  Command_P2POperation_Peer(const Command_P2POperation_Peer& from);

  inline Command_P2POperation_Peer& operator=(const Command_P2POperation_Peer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_P2POperation_Peer& default_instance();

  void Swap(Command_P2POperation_Peer* other);

  // implements Message ----------------------------------------------

  Command_P2POperation_Peer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_P2POperation_Peer& from);
  void MergeFrom(const Command_P2POperation_Peer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hostname = 1;
  inline bool has_hostname() const;
  inline void clear_hostname();
  static const int kHostnameFieldNumber = 1;
  inline const ::std::string& hostname() const;
  inline void set_hostname(const ::std::string& value);
  inline void set_hostname(const char* value);
  inline void set_hostname(const char* value, size_t size);
  inline ::std::string* mutable_hostname();
  inline ::std::string* release_hostname();
  inline void set_allocated_hostname(::std::string* hostname);

  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional bool tls = 3;
  inline bool has_tls() const;
  inline void clear_tls();
  static const int kTlsFieldNumber = 3;
  inline bool tls() const;
  inline void set_tls(bool value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.P2POperation.Peer)
 private:
  inline void set_has_hostname();
  inline void clear_has_hostname();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_tls();
  inline void clear_has_tls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hostname_;
  ::google::protobuf::int32 port_;
  bool tls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_P2POperation_Peer* default_instance_;
};
// -------------------------------------------------------------------

class Command_P2POperation : public ::google::protobuf::Message {
 public:
  Command_P2POperation();
  virtual ~Command_P2POperation();

  Command_P2POperation(const Command_P2POperation& from);

  inline Command_P2POperation& operator=(const Command_P2POperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_P2POperation& default_instance();

  void Swap(Command_P2POperation* other);

  // implements Message ----------------------------------------------

  Command_P2POperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_P2POperation& from);
  void MergeFrom(const Command_P2POperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_P2POperation_Operation Operation;
  typedef Command_P2POperation_Peer Peer;

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Command.P2POperation.Peer peer = 1;
  inline bool has_peer() const;
  inline void clear_peer();
  static const int kPeerFieldNumber = 1;
  inline const ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer& peer() const;
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* mutable_peer();
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* release_peer();
  inline void set_allocated_peer(::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* peer);

  // repeated .com.seagate.kinetic.client.proto.Command.P2POperation.Operation operation = 2;
  inline int operation_size() const;
  inline void clear_operation();
  static const int kOperationFieldNumber = 2;
  inline const ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation& operation(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation* mutable_operation(int index);
  inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation* add_operation();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation >&
      operation() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation >*
      mutable_operation();

  // optional bool allChildOperationsSucceeded = 3;
  inline bool has_allchildoperationssucceeded() const;
  inline void clear_allchildoperationssucceeded();
  static const int kAllChildOperationsSucceededFieldNumber = 3;
  inline bool allchildoperationssucceeded() const;
  inline void set_allchildoperationssucceeded(bool value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.P2POperation)
 private:
  inline void set_has_peer();
  inline void clear_has_peer();
  inline void set_has_allchildoperationssucceeded();
  inline void clear_has_allchildoperationssucceeded();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* peer_;
  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation > operation_;
  bool allchildoperationssucceeded_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_P2POperation* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Utilization : public ::google::protobuf::Message {
 public:
  Command_GetLog_Utilization();
  virtual ~Command_GetLog_Utilization();

  Command_GetLog_Utilization(const Command_GetLog_Utilization& from);

  inline Command_GetLog_Utilization& operator=(const Command_GetLog_Utilization& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Utilization& default_instance();

  void Swap(Command_GetLog_Utilization* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Utilization* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Utilization& from);
  void MergeFrom(const Command_GetLog_Utilization& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline float value() const;
  inline void set_value(float value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Utilization)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  float value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Utilization* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Temperature : public ::google::protobuf::Message {
 public:
  Command_GetLog_Temperature();
  virtual ~Command_GetLog_Temperature();

  Command_GetLog_Temperature(const Command_GetLog_Temperature& from);

  inline Command_GetLog_Temperature& operator=(const Command_GetLog_Temperature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Temperature& default_instance();

  void Swap(Command_GetLog_Temperature* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Temperature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Temperature& from);
  void MergeFrom(const Command_GetLog_Temperature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float current = 2;
  inline bool has_current() const;
  inline void clear_current();
  static const int kCurrentFieldNumber = 2;
  inline float current() const;
  inline void set_current(float value);

  // optional float minimum = 3;
  inline bool has_minimum() const;
  inline void clear_minimum();
  static const int kMinimumFieldNumber = 3;
  inline float minimum() const;
  inline void set_minimum(float value);

  // optional float maximum = 4;
  inline bool has_maximum() const;
  inline void clear_maximum();
  static const int kMaximumFieldNumber = 4;
  inline float maximum() const;
  inline void set_maximum(float value);

  // optional float target = 5;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 5;
  inline float target() const;
  inline void set_target(float value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Temperature)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_current();
  inline void clear_has_current();
  inline void set_has_minimum();
  inline void clear_has_minimum();
  inline void set_has_maximum();
  inline void clear_has_maximum();
  inline void set_has_target();
  inline void clear_has_target();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  float current_;
  float minimum_;
  float maximum_;
  float target_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Temperature* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Capacity : public ::google::protobuf::Message {
 public:
  Command_GetLog_Capacity();
  virtual ~Command_GetLog_Capacity();

  Command_GetLog_Capacity(const Command_GetLog_Capacity& from);

  inline Command_GetLog_Capacity& operator=(const Command_GetLog_Capacity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Capacity& default_instance();

  void Swap(Command_GetLog_Capacity* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Capacity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Capacity& from);
  void MergeFrom(const Command_GetLog_Capacity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 nominalCapacityInBytes = 4;
  inline bool has_nominalcapacityinbytes() const;
  inline void clear_nominalcapacityinbytes();
  static const int kNominalCapacityInBytesFieldNumber = 4;
  inline ::google::protobuf::uint64 nominalcapacityinbytes() const;
  inline void set_nominalcapacityinbytes(::google::protobuf::uint64 value);

  // optional float portionFull = 5;
  inline bool has_portionfull() const;
  inline void clear_portionfull();
  static const int kPortionFullFieldNumber = 5;
  inline float portionfull() const;
  inline void set_portionfull(float value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Capacity)
 private:
  inline void set_has_nominalcapacityinbytes();
  inline void clear_has_nominalcapacityinbytes();
  inline void set_has_portionfull();
  inline void clear_has_portionfull();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 nominalcapacityinbytes_;
  float portionfull_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Capacity* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Configuration_Interface : public ::google::protobuf::Message {
 public:
  Command_GetLog_Configuration_Interface();
  virtual ~Command_GetLog_Configuration_Interface();

  Command_GetLog_Configuration_Interface(const Command_GetLog_Configuration_Interface& from);

  inline Command_GetLog_Configuration_Interface& operator=(const Command_GetLog_Configuration_Interface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Configuration_Interface& default_instance();

  void Swap(Command_GetLog_Configuration_Interface* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Configuration_Interface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Configuration_Interface& from);
  void MergeFrom(const Command_GetLog_Configuration_Interface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes MAC = 2;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMACFieldNumber = 2;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const void* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional bytes ipv4Address = 3;
  inline bool has_ipv4address() const;
  inline void clear_ipv4address();
  static const int kIpv4AddressFieldNumber = 3;
  inline const ::std::string& ipv4address() const;
  inline void set_ipv4address(const ::std::string& value);
  inline void set_ipv4address(const char* value);
  inline void set_ipv4address(const void* value, size_t size);
  inline ::std::string* mutable_ipv4address();
  inline ::std::string* release_ipv4address();
  inline void set_allocated_ipv4address(::std::string* ipv4address);

  // optional bytes ipv6Address = 4;
  inline bool has_ipv6address() const;
  inline void clear_ipv6address();
  static const int kIpv6AddressFieldNumber = 4;
  inline const ::std::string& ipv6address() const;
  inline void set_ipv6address(const ::std::string& value);
  inline void set_ipv6address(const char* value);
  inline void set_ipv6address(const void* value, size_t size);
  inline ::std::string* mutable_ipv6address();
  inline ::std::string* release_ipv6address();
  inline void set_allocated_ipv6address(::std::string* ipv6address);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Configuration.Interface)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_ipv4address();
  inline void clear_has_ipv4address();
  inline void set_has_ipv6address();
  inline void clear_has_ipv6address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* mac_;
  ::std::string* ipv4address_;
  ::std::string* ipv6address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Configuration_Interface* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Configuration : public ::google::protobuf::Message {
 public:
  Command_GetLog_Configuration();
  virtual ~Command_GetLog_Configuration();

  Command_GetLog_Configuration(const Command_GetLog_Configuration& from);

  inline Command_GetLog_Configuration& operator=(const Command_GetLog_Configuration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Configuration& default_instance();

  void Swap(Command_GetLog_Configuration* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Configuration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Configuration& from);
  void MergeFrom(const Command_GetLog_Configuration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_GetLog_Configuration_Interface Interface;

  // accessors -------------------------------------------------------

  // optional string vendor = 5;
  inline bool has_vendor() const;
  inline void clear_vendor();
  static const int kVendorFieldNumber = 5;
  inline const ::std::string& vendor() const;
  inline void set_vendor(const ::std::string& value);
  inline void set_vendor(const char* value);
  inline void set_vendor(const char* value, size_t size);
  inline ::std::string* mutable_vendor();
  inline ::std::string* release_vendor();
  inline void set_allocated_vendor(::std::string* vendor);

  // optional string model = 6;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 6;
  inline const ::std::string& model() const;
  inline void set_model(const ::std::string& value);
  inline void set_model(const char* value);
  inline void set_model(const char* value, size_t size);
  inline ::std::string* mutable_model();
  inline ::std::string* release_model();
  inline void set_allocated_model(::std::string* model);

  // optional bytes serialNumber = 7;
  inline bool has_serialnumber() const;
  inline void clear_serialnumber();
  static const int kSerialNumberFieldNumber = 7;
  inline const ::std::string& serialnumber() const;
  inline void set_serialnumber(const ::std::string& value);
  inline void set_serialnumber(const char* value);
  inline void set_serialnumber(const void* value, size_t size);
  inline ::std::string* mutable_serialnumber();
  inline ::std::string* release_serialnumber();
  inline void set_allocated_serialnumber(::std::string* serialnumber);

  // optional bytes worldWideName = 14;
  inline bool has_worldwidename() const;
  inline void clear_worldwidename();
  static const int kWorldWideNameFieldNumber = 14;
  inline const ::std::string& worldwidename() const;
  inline void set_worldwidename(const ::std::string& value);
  inline void set_worldwidename(const char* value);
  inline void set_worldwidename(const void* value, size_t size);
  inline ::std::string* mutable_worldwidename();
  inline ::std::string* release_worldwidename();
  inline void set_allocated_worldwidename(::std::string* worldwidename);

  // optional string version = 8;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 8;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string compilationDate = 12;
  inline bool has_compilationdate() const;
  inline void clear_compilationdate();
  static const int kCompilationDateFieldNumber = 12;
  inline const ::std::string& compilationdate() const;
  inline void set_compilationdate(const ::std::string& value);
  inline void set_compilationdate(const char* value);
  inline void set_compilationdate(const char* value, size_t size);
  inline ::std::string* mutable_compilationdate();
  inline ::std::string* release_compilationdate();
  inline void set_allocated_compilationdate(::std::string* compilationdate);

  // optional string sourceHash = 13;
  inline bool has_sourcehash() const;
  inline void clear_sourcehash();
  static const int kSourceHashFieldNumber = 13;
  inline const ::std::string& sourcehash() const;
  inline void set_sourcehash(const ::std::string& value);
  inline void set_sourcehash(const char* value);
  inline void set_sourcehash(const char* value, size_t size);
  inline ::std::string* mutable_sourcehash();
  inline ::std::string* release_sourcehash();
  inline void set_allocated_sourcehash(::std::string* sourcehash);

  // optional string protocolVersion = 15;
  inline bool has_protocolversion() const;
  inline void clear_protocolversion();
  static const int kProtocolVersionFieldNumber = 15;
  inline const ::std::string& protocolversion() const;
  inline void set_protocolversion(const ::std::string& value);
  inline void set_protocolversion(const char* value);
  inline void set_protocolversion(const char* value, size_t size);
  inline ::std::string* mutable_protocolversion();
  inline ::std::string* release_protocolversion();
  inline void set_allocated_protocolversion(::std::string* protocolversion);

  // optional string protocolCompilationDate = 16;
  inline bool has_protocolcompilationdate() const;
  inline void clear_protocolcompilationdate();
  static const int kProtocolCompilationDateFieldNumber = 16;
  inline const ::std::string& protocolcompilationdate() const;
  inline void set_protocolcompilationdate(const ::std::string& value);
  inline void set_protocolcompilationdate(const char* value);
  inline void set_protocolcompilationdate(const char* value, size_t size);
  inline ::std::string* mutable_protocolcompilationdate();
  inline ::std::string* release_protocolcompilationdate();
  inline void set_allocated_protocolcompilationdate(::std::string* protocolcompilationdate);

  // optional string protocolSourceHash = 17;
  inline bool has_protocolsourcehash() const;
  inline void clear_protocolsourcehash();
  static const int kProtocolSourceHashFieldNumber = 17;
  inline const ::std::string& protocolsourcehash() const;
  inline void set_protocolsourcehash(const ::std::string& value);
  inline void set_protocolsourcehash(const char* value);
  inline void set_protocolsourcehash(const char* value, size_t size);
  inline ::std::string* mutable_protocolsourcehash();
  inline ::std::string* release_protocolsourcehash();
  inline void set_allocated_protocolsourcehash(::std::string* protocolsourcehash);

  // repeated .com.seagate.kinetic.client.proto.Command.GetLog.Configuration.Interface interface = 9;
  inline int interface_size() const;
  inline void clear_interface();
  static const int kInterfaceFieldNumber = 9;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface& interface(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface* mutable_interface(int index);
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface* add_interface();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface >&
      interface() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface >*
      mutable_interface();

  // optional int32 port = 10;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 10;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);

  // optional int32 tlsPort = 11;
  inline bool has_tlsport() const;
  inline void clear_tlsport();
  static const int kTlsPortFieldNumber = 11;
  inline ::google::protobuf::int32 tlsport() const;
  inline void set_tlsport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Configuration)
 private:
  inline void set_has_vendor();
  inline void clear_has_vendor();
  inline void set_has_model();
  inline void clear_has_model();
  inline void set_has_serialnumber();
  inline void clear_has_serialnumber();
  inline void set_has_worldwidename();
  inline void clear_has_worldwidename();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_compilationdate();
  inline void clear_has_compilationdate();
  inline void set_has_sourcehash();
  inline void clear_has_sourcehash();
  inline void set_has_protocolversion();
  inline void clear_has_protocolversion();
  inline void set_has_protocolcompilationdate();
  inline void clear_has_protocolcompilationdate();
  inline void set_has_protocolsourcehash();
  inline void clear_has_protocolsourcehash();
  inline void set_has_port();
  inline void clear_has_port();
  inline void set_has_tlsport();
  inline void clear_has_tlsport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* vendor_;
  ::std::string* model_;
  ::std::string* serialnumber_;
  ::std::string* worldwidename_;
  ::std::string* version_;
  ::std::string* compilationdate_;
  ::std::string* sourcehash_;
  ::std::string* protocolversion_;
  ::std::string* protocolcompilationdate_;
  ::std::string* protocolsourcehash_;
  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface > interface_;
  ::google::protobuf::int32 port_;
  ::google::protobuf::int32 tlsport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Configuration* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Statistics : public ::google::protobuf::Message {
 public:
  Command_GetLog_Statistics();
  virtual ~Command_GetLog_Statistics();

  Command_GetLog_Statistics(const Command_GetLog_Statistics& from);

  inline Command_GetLog_Statistics& operator=(const Command_GetLog_Statistics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Statistics& default_instance();

  void Swap(Command_GetLog_Statistics* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Statistics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Statistics& from);
  void MergeFrom(const Command_GetLog_Statistics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Command.MessageType messageType = 1;
  inline bool has_messagetype() const;
  inline void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  inline ::com::seagate::kinetic::client::proto::Command_MessageType messagetype() const;
  inline void set_messagetype(::com::seagate::kinetic::client::proto::Command_MessageType value);

  // optional uint64 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::uint64 count() const;
  inline void set_count(::google::protobuf::uint64 value);

  // optional uint64 bytes = 5;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 5;
  inline ::google::protobuf::uint64 bytes() const;
  inline void set_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Statistics)
 private:
  inline void set_has_messagetype();
  inline void clear_has_messagetype();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_bytes();
  inline void clear_has_bytes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 count_;
  ::google::protobuf::uint64 bytes_;
  int messagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Statistics* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Limits : public ::google::protobuf::Message {
 public:
  Command_GetLog_Limits();
  virtual ~Command_GetLog_Limits();

  Command_GetLog_Limits(const Command_GetLog_Limits& from);

  inline Command_GetLog_Limits& operator=(const Command_GetLog_Limits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Limits& default_instance();

  void Swap(Command_GetLog_Limits* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Limits* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Limits& from);
  void MergeFrom(const Command_GetLog_Limits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 maxKeySize = 1;
  inline bool has_maxkeysize() const;
  inline void clear_maxkeysize();
  static const int kMaxKeySizeFieldNumber = 1;
  inline ::google::protobuf::uint32 maxkeysize() const;
  inline void set_maxkeysize(::google::protobuf::uint32 value);

  // optional uint32 maxValueSize = 2;
  inline bool has_maxvaluesize() const;
  inline void clear_maxvaluesize();
  static const int kMaxValueSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 maxvaluesize() const;
  inline void set_maxvaluesize(::google::protobuf::uint32 value);

  // optional uint32 maxVersionSize = 3;
  inline bool has_maxversionsize() const;
  inline void clear_maxversionsize();
  static const int kMaxVersionSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 maxversionsize() const;
  inline void set_maxversionsize(::google::protobuf::uint32 value);

  // optional uint32 maxTagSize = 4;
  inline bool has_maxtagsize() const;
  inline void clear_maxtagsize();
  static const int kMaxTagSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 maxtagsize() const;
  inline void set_maxtagsize(::google::protobuf::uint32 value);

  // optional uint32 maxConnections = 5;
  inline bool has_maxconnections() const;
  inline void clear_maxconnections();
  static const int kMaxConnectionsFieldNumber = 5;
  inline ::google::protobuf::uint32 maxconnections() const;
  inline void set_maxconnections(::google::protobuf::uint32 value);

  // optional uint32 maxOutstandingReadRequests = 6;
  inline bool has_maxoutstandingreadrequests() const;
  inline void clear_maxoutstandingreadrequests();
  static const int kMaxOutstandingReadRequestsFieldNumber = 6;
  inline ::google::protobuf::uint32 maxoutstandingreadrequests() const;
  inline void set_maxoutstandingreadrequests(::google::protobuf::uint32 value);

  // optional uint32 maxOutstandingWriteRequests = 7;
  inline bool has_maxoutstandingwriterequests() const;
  inline void clear_maxoutstandingwriterequests();
  static const int kMaxOutstandingWriteRequestsFieldNumber = 7;
  inline ::google::protobuf::uint32 maxoutstandingwriterequests() const;
  inline void set_maxoutstandingwriterequests(::google::protobuf::uint32 value);

  // optional uint32 maxMessageSize = 8;
  inline bool has_maxmessagesize() const;
  inline void clear_maxmessagesize();
  static const int kMaxMessageSizeFieldNumber = 8;
  inline ::google::protobuf::uint32 maxmessagesize() const;
  inline void set_maxmessagesize(::google::protobuf::uint32 value);

  // optional uint32 maxKeyRangeCount = 9;
  inline bool has_maxkeyrangecount() const;
  inline void clear_maxkeyrangecount();
  static const int kMaxKeyRangeCountFieldNumber = 9;
  inline ::google::protobuf::uint32 maxkeyrangecount() const;
  inline void set_maxkeyrangecount(::google::protobuf::uint32 value);

  // optional uint32 maxIdentityCount = 10;
  inline bool has_maxidentitycount() const;
  inline void clear_maxidentitycount();
  static const int kMaxIdentityCountFieldNumber = 10;
  inline ::google::protobuf::uint32 maxidentitycount() const;
  inline void set_maxidentitycount(::google::protobuf::uint32 value);

  // optional uint32 maxPinSize = 11;
  inline bool has_maxpinsize() const;
  inline void clear_maxpinsize();
  static const int kMaxPinSizeFieldNumber = 11;
  inline ::google::protobuf::uint32 maxpinsize() const;
  inline void set_maxpinsize(::google::protobuf::uint32 value);

  // optional uint32 maxOperationCountPerBatch = 12;
  inline bool has_maxoperationcountperbatch() const;
  inline void clear_maxoperationcountperbatch();
  static const int kMaxOperationCountPerBatchFieldNumber = 12;
  inline ::google::protobuf::uint32 maxoperationcountperbatch() const;
  inline void set_maxoperationcountperbatch(::google::protobuf::uint32 value);

  // optional uint32 maxBatchCountPerDevice = 13;
  inline bool has_maxbatchcountperdevice() const;
  inline void clear_maxbatchcountperdevice();
  static const int kMaxBatchCountPerDeviceFieldNumber = 13;
  inline ::google::protobuf::uint32 maxbatchcountperdevice() const;
  inline void set_maxbatchcountperdevice(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Limits)
 private:
  inline void set_has_maxkeysize();
  inline void clear_has_maxkeysize();
  inline void set_has_maxvaluesize();
  inline void clear_has_maxvaluesize();
  inline void set_has_maxversionsize();
  inline void clear_has_maxversionsize();
  inline void set_has_maxtagsize();
  inline void clear_has_maxtagsize();
  inline void set_has_maxconnections();
  inline void clear_has_maxconnections();
  inline void set_has_maxoutstandingreadrequests();
  inline void clear_has_maxoutstandingreadrequests();
  inline void set_has_maxoutstandingwriterequests();
  inline void clear_has_maxoutstandingwriterequests();
  inline void set_has_maxmessagesize();
  inline void clear_has_maxmessagesize();
  inline void set_has_maxkeyrangecount();
  inline void clear_has_maxkeyrangecount();
  inline void set_has_maxidentitycount();
  inline void clear_has_maxidentitycount();
  inline void set_has_maxpinsize();
  inline void clear_has_maxpinsize();
  inline void set_has_maxoperationcountperbatch();
  inline void clear_has_maxoperationcountperbatch();
  inline void set_has_maxbatchcountperdevice();
  inline void clear_has_maxbatchcountperdevice();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 maxkeysize_;
  ::google::protobuf::uint32 maxvaluesize_;
  ::google::protobuf::uint32 maxversionsize_;
  ::google::protobuf::uint32 maxtagsize_;
  ::google::protobuf::uint32 maxconnections_;
  ::google::protobuf::uint32 maxoutstandingreadrequests_;
  ::google::protobuf::uint32 maxoutstandingwriterequests_;
  ::google::protobuf::uint32 maxmessagesize_;
  ::google::protobuf::uint32 maxkeyrangecount_;
  ::google::protobuf::uint32 maxidentitycount_;
  ::google::protobuf::uint32 maxpinsize_;
  ::google::protobuf::uint32 maxoperationcountperbatch_;
  ::google::protobuf::uint32 maxbatchcountperdevice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Limits* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog_Device : public ::google::protobuf::Message {
 public:
  Command_GetLog_Device();
  virtual ~Command_GetLog_Device();

  Command_GetLog_Device(const Command_GetLog_Device& from);

  inline Command_GetLog_Device& operator=(const Command_GetLog_Device& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog_Device& default_instance();

  void Swap(Command_GetLog_Device* other);

  // implements Message ----------------------------------------------

  Command_GetLog_Device* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog_Device& from);
  void MergeFrom(const Command_GetLog_Device& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const void* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog.Device)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog_Device* default_instance_;
};
// -------------------------------------------------------------------

class Command_GetLog : public ::google::protobuf::Message {
 public:
  Command_GetLog();
  virtual ~Command_GetLog();

  Command_GetLog(const Command_GetLog& from);

  inline Command_GetLog& operator=(const Command_GetLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_GetLog& default_instance();

  void Swap(Command_GetLog* other);

  // implements Message ----------------------------------------------

  Command_GetLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_GetLog& from);
  void MergeFrom(const Command_GetLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_GetLog_Utilization Utilization;
  typedef Command_GetLog_Temperature Temperature;
  typedef Command_GetLog_Capacity Capacity;
  typedef Command_GetLog_Configuration Configuration;
  typedef Command_GetLog_Statistics Statistics;
  typedef Command_GetLog_Limits Limits;
  typedef Command_GetLog_Device Device;

  typedef Command_GetLog_Type Type;
  static const Type INVALID_TYPE = Command_GetLog_Type_INVALID_TYPE;
  static const Type UTILIZATIONS = Command_GetLog_Type_UTILIZATIONS;
  static const Type TEMPERATURES = Command_GetLog_Type_TEMPERATURES;
  static const Type CAPACITIES = Command_GetLog_Type_CAPACITIES;
  static const Type CONFIGURATION = Command_GetLog_Type_CONFIGURATION;
  static const Type STATISTICS = Command_GetLog_Type_STATISTICS;
  static const Type MESSAGES = Command_GetLog_Type_MESSAGES;
  static const Type LIMITS = Command_GetLog_Type_LIMITS;
  static const Type DEVICE = Command_GetLog_Type_DEVICE;
  static inline bool Type_IsValid(int value) {
    return Command_GetLog_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Command_GetLog_Type_Type_MIN;
  static const Type Type_MAX =
    Command_GetLog_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Command_GetLog_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Command_GetLog_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Command_GetLog_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Command_GetLog_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .com.seagate.kinetic.client.proto.Command.GetLog.Type types = 1;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 1;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Type types(int index) const;
  inline void set_types(int index, ::com::seagate::kinetic::client::proto::Command_GetLog_Type value);
  inline void add_types(::com::seagate::kinetic::client::proto::Command_GetLog_Type value);
  inline const ::google::protobuf::RepeatedField<int>& types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_types();

  // repeated .com.seagate.kinetic.client.proto.Command.GetLog.Utilization utilizations = 2;
  inline int utilizations_size() const;
  inline void clear_utilizations();
  static const int kUtilizationsFieldNumber = 2;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization& utilizations(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization* mutable_utilizations(int index);
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization* add_utilizations();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization >&
      utilizations() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization >*
      mutable_utilizations();

  // repeated .com.seagate.kinetic.client.proto.Command.GetLog.Temperature temperatures = 3;
  inline int temperatures_size() const;
  inline void clear_temperatures();
  static const int kTemperaturesFieldNumber = 3;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature& temperatures(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature* mutable_temperatures(int index);
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature* add_temperatures();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature >&
      temperatures() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature >*
      mutable_temperatures();

  // optional .com.seagate.kinetic.client.proto.Command.GetLog.Capacity capacity = 4;
  inline bool has_capacity() const;
  inline void clear_capacity();
  static const int kCapacityFieldNumber = 4;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity& capacity() const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* mutable_capacity();
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* release_capacity();
  inline void set_allocated_capacity(::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* capacity);

  // optional .com.seagate.kinetic.client.proto.Command.GetLog.Configuration configuration = 5;
  inline bool has_configuration() const;
  inline void clear_configuration();
  static const int kConfigurationFieldNumber = 5;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration& configuration() const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* mutable_configuration();
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* release_configuration();
  inline void set_allocated_configuration(::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* configuration);

  // repeated .com.seagate.kinetic.client.proto.Command.GetLog.Statistics statistics = 6;
  inline int statistics_size() const;
  inline void clear_statistics();
  static const int kStatisticsFieldNumber = 6;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics& statistics(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics* mutable_statistics(int index);
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics* add_statistics();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics >&
      statistics() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics >*
      mutable_statistics();

  // optional bytes messages = 7;
  inline bool has_messages() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 7;
  inline const ::std::string& messages() const;
  inline void set_messages(const ::std::string& value);
  inline void set_messages(const char* value);
  inline void set_messages(const void* value, size_t size);
  inline ::std::string* mutable_messages();
  inline ::std::string* release_messages();
  inline void set_allocated_messages(::std::string* messages);

  // optional .com.seagate.kinetic.client.proto.Command.GetLog.Limits limits = 8;
  inline bool has_limits() const;
  inline void clear_limits();
  static const int kLimitsFieldNumber = 8;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Limits& limits() const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Limits* mutable_limits();
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Limits* release_limits();
  inline void set_allocated_limits(::com::seagate::kinetic::client::proto::Command_GetLog_Limits* limits);

  // optional .com.seagate.kinetic.client.proto.Command.GetLog.Device device = 9;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 9;
  inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Device& device() const;
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Device* mutable_device();
  inline ::com::seagate::kinetic::client::proto::Command_GetLog_Device* release_device();
  inline void set_allocated_device(::com::seagate::kinetic::client::proto::Command_GetLog_Device* device);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.GetLog)
 private:
  inline void set_has_capacity();
  inline void clear_has_capacity();
  inline void set_has_configuration();
  inline void clear_has_configuration();
  inline void set_has_messages();
  inline void clear_has_messages();
  inline void set_has_limits();
  inline void clear_has_limits();
  inline void set_has_device();
  inline void clear_has_device();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> types_;
  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization > utilizations_;
  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature > temperatures_;
  ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* capacity_;
  ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* configuration_;
  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics > statistics_;
  ::std::string* messages_;
  ::com::seagate::kinetic::client::proto::Command_GetLog_Limits* limits_;
  ::com::seagate::kinetic::client::proto::Command_GetLog_Device* device_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_GetLog* default_instance_;
};
// -------------------------------------------------------------------

class Command_Security_ACL_Scope : public ::google::protobuf::Message {
 public:
  Command_Security_ACL_Scope();
  virtual ~Command_Security_ACL_Scope();

  Command_Security_ACL_Scope(const Command_Security_ACL_Scope& from);

  inline Command_Security_ACL_Scope& operator=(const Command_Security_ACL_Scope& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Security_ACL_Scope& default_instance();

  void Swap(Command_Security_ACL_Scope* other);

  // implements Message ----------------------------------------------

  Command_Security_ACL_Scope* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Security_ACL_Scope& from);
  void MergeFrom(const Command_Security_ACL_Scope& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 offset = 1;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 1;
  inline ::google::protobuf::int64 offset() const;
  inline void set_offset(::google::protobuf::int64 value);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // repeated .com.seagate.kinetic.client.proto.Command.Security.ACL.Permission permission = 3;
  inline int permission_size() const;
  inline void clear_permission();
  static const int kPermissionFieldNumber = 3;
  inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission permission(int index) const;
  inline void set_permission(int index, ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission value);
  inline void add_permission(::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission value);
  inline const ::google::protobuf::RepeatedField<int>& permission() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_permission();

  // optional bool TlsRequired = 4;
  inline bool has_tlsrequired() const;
  inline void clear_tlsrequired();
  static const int kTlsRequiredFieldNumber = 4;
  inline bool tlsrequired() const;
  inline void set_tlsrequired(bool value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Security.ACL.Scope)
 private:
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_tlsrequired();
  inline void clear_has_tlsrequired();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 offset_;
  ::std::string* value_;
  ::google::protobuf::RepeatedField<int> permission_;
  bool tlsrequired_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Security_ACL_Scope* default_instance_;
};
// -------------------------------------------------------------------

class Command_Security_ACL : public ::google::protobuf::Message {
 public:
  Command_Security_ACL();
  virtual ~Command_Security_ACL();

  Command_Security_ACL(const Command_Security_ACL& from);

  inline Command_Security_ACL& operator=(const Command_Security_ACL& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Security_ACL& default_instance();

  void Swap(Command_Security_ACL* other);

  // implements Message ----------------------------------------------

  Command_Security_ACL* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Security_ACL& from);
  void MergeFrom(const Command_Security_ACL& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Security_ACL_Scope Scope;

  typedef Command_Security_ACL_HMACAlgorithm HMACAlgorithm;
  static const HMACAlgorithm INVALID_HMAC_ALGORITHM = Command_Security_ACL_HMACAlgorithm_INVALID_HMAC_ALGORITHM;
  static const HMACAlgorithm HmacSHA1 = Command_Security_ACL_HMACAlgorithm_HmacSHA1;
  static inline bool HMACAlgorithm_IsValid(int value) {
    return Command_Security_ACL_HMACAlgorithm_IsValid(value);
  }
  static const HMACAlgorithm HMACAlgorithm_MIN =
    Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_MIN;
  static const HMACAlgorithm HMACAlgorithm_MAX =
    Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_MAX;
  static const int HMACAlgorithm_ARRAYSIZE =
    Command_Security_ACL_HMACAlgorithm_HMACAlgorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HMACAlgorithm_descriptor() {
    return Command_Security_ACL_HMACAlgorithm_descriptor();
  }
  static inline const ::std::string& HMACAlgorithm_Name(HMACAlgorithm value) {
    return Command_Security_ACL_HMACAlgorithm_Name(value);
  }
  static inline bool HMACAlgorithm_Parse(const ::std::string& name,
      HMACAlgorithm* value) {
    return Command_Security_ACL_HMACAlgorithm_Parse(name, value);
  }

  typedef Command_Security_ACL_Permission Permission;
  static const Permission INVALID_PERMISSION = Command_Security_ACL_Permission_INVALID_PERMISSION;
  static const Permission READ = Command_Security_ACL_Permission_READ;
  static const Permission WRITE = Command_Security_ACL_Permission_WRITE;
  static const Permission DELETE = Command_Security_ACL_Permission_DELETE;
  static const Permission RANGE = Command_Security_ACL_Permission_RANGE;
  static const Permission SETUP = Command_Security_ACL_Permission_SETUP;
  static const Permission P2POP = Command_Security_ACL_Permission_P2POP;
  static const Permission GETLOG = Command_Security_ACL_Permission_GETLOG;
  static const Permission SECURITY = Command_Security_ACL_Permission_SECURITY;
  static inline bool Permission_IsValid(int value) {
    return Command_Security_ACL_Permission_IsValid(value);
  }
  static const Permission Permission_MIN =
    Command_Security_ACL_Permission_Permission_MIN;
  static const Permission Permission_MAX =
    Command_Security_ACL_Permission_Permission_MAX;
  static const int Permission_ARRAYSIZE =
    Command_Security_ACL_Permission_Permission_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Permission_descriptor() {
    return Command_Security_ACL_Permission_descriptor();
  }
  static inline const ::std::string& Permission_Name(Permission value) {
    return Command_Security_ACL_Permission_Name(value);
  }
  static inline bool Permission_Parse(const ::std::string& name,
      Permission* value) {
    return Command_Security_ACL_Permission_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int64 identity = 1;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 1;
  inline ::google::protobuf::int64 identity() const;
  inline void set_identity(::google::protobuf::int64 value);

  // optional bytes key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .com.seagate.kinetic.client.proto.Command.Security.ACL.HMACAlgorithm hmacAlgorithm = 3;
  inline bool has_hmacalgorithm() const;
  inline void clear_hmacalgorithm();
  static const int kHmacAlgorithmFieldNumber = 3;
  inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm hmacalgorithm() const;
  inline void set_hmacalgorithm(::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm value);

  // repeated .com.seagate.kinetic.client.proto.Command.Security.ACL.Scope scope = 4;
  inline int scope_size() const;
  inline void clear_scope();
  static const int kScopeFieldNumber = 4;
  inline const ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope& scope(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope* mutable_scope(int index);
  inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope* add_scope();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope >&
      scope() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope >*
      mutable_scope();

  // optional .com.seagate.kinetic.client.proto.Command.Priority maxPriority = 5;
  inline bool has_maxpriority() const;
  inline void clear_maxpriority();
  static const int kMaxPriorityFieldNumber = 5;
  inline ::com::seagate::kinetic::client::proto::Command_Priority maxpriority() const;
  inline void set_maxpriority(::com::seagate::kinetic::client::proto::Command_Priority value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Security.ACL)
 private:
  inline void set_has_identity();
  inline void clear_has_identity();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_hmacalgorithm();
  inline void clear_has_hmacalgorithm();
  inline void set_has_maxpriority();
  inline void clear_has_maxpriority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 identity_;
  ::std::string* key_;
  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope > scope_;
  int hmacalgorithm_;
  int maxpriority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Security_ACL* default_instance_;
};
// -------------------------------------------------------------------

class Command_Security : public ::google::protobuf::Message {
 public:
  Command_Security();
  virtual ~Command_Security();

  Command_Security(const Command_Security& from);

  inline Command_Security& operator=(const Command_Security& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_Security& default_instance();

  void Swap(Command_Security* other);

  // implements Message ----------------------------------------------

  Command_Security* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_Security& from);
  void MergeFrom(const Command_Security& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Security_ACL ACL;

  // accessors -------------------------------------------------------

  // repeated .com.seagate.kinetic.client.proto.Command.Security.ACL acl = 2;
  inline int acl_size() const;
  inline void clear_acl();
  static const int kAclFieldNumber = 2;
  inline const ::com::seagate::kinetic::client::proto::Command_Security_ACL& acl(int index) const;
  inline ::com::seagate::kinetic::client::proto::Command_Security_ACL* mutable_acl(int index);
  inline ::com::seagate::kinetic::client::proto::Command_Security_ACL* add_acl();
  inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL >&
      acl() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL >*
      mutable_acl();

  // optional bytes oldLockPIN = 3;
  inline bool has_oldlockpin() const;
  inline void clear_oldlockpin();
  static const int kOldLockPINFieldNumber = 3;
  inline const ::std::string& oldlockpin() const;
  inline void set_oldlockpin(const ::std::string& value);
  inline void set_oldlockpin(const char* value);
  inline void set_oldlockpin(const void* value, size_t size);
  inline ::std::string* mutable_oldlockpin();
  inline ::std::string* release_oldlockpin();
  inline void set_allocated_oldlockpin(::std::string* oldlockpin);

  // optional bytes newLockPIN = 4;
  inline bool has_newlockpin() const;
  inline void clear_newlockpin();
  static const int kNewLockPINFieldNumber = 4;
  inline const ::std::string& newlockpin() const;
  inline void set_newlockpin(const ::std::string& value);
  inline void set_newlockpin(const char* value);
  inline void set_newlockpin(const void* value, size_t size);
  inline ::std::string* mutable_newlockpin();
  inline ::std::string* release_newlockpin();
  inline void set_allocated_newlockpin(::std::string* newlockpin);

  // optional bytes oldErasePIN = 5;
  inline bool has_olderasepin() const;
  inline void clear_olderasepin();
  static const int kOldErasePINFieldNumber = 5;
  inline const ::std::string& olderasepin() const;
  inline void set_olderasepin(const ::std::string& value);
  inline void set_olderasepin(const char* value);
  inline void set_olderasepin(const void* value, size_t size);
  inline ::std::string* mutable_olderasepin();
  inline ::std::string* release_olderasepin();
  inline void set_allocated_olderasepin(::std::string* olderasepin);

  // optional bytes newErasePIN = 6;
  inline bool has_newerasepin() const;
  inline void clear_newerasepin();
  static const int kNewErasePINFieldNumber = 6;
  inline const ::std::string& newerasepin() const;
  inline void set_newerasepin(const ::std::string& value);
  inline void set_newerasepin(const char* value);
  inline void set_newerasepin(const void* value, size_t size);
  inline ::std::string* mutable_newerasepin();
  inline ::std::string* release_newerasepin();
  inline void set_allocated_newerasepin(::std::string* newerasepin);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.Security)
 private:
  inline void set_has_oldlockpin();
  inline void clear_has_oldlockpin();
  inline void set_has_newlockpin();
  inline void clear_has_newlockpin();
  inline void set_has_olderasepin();
  inline void clear_has_olderasepin();
  inline void set_has_newerasepin();
  inline void clear_has_newerasepin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL > acl_;
  ::std::string* oldlockpin_;
  ::std::string* newlockpin_;
  ::std::string* olderasepin_;
  ::std::string* newerasepin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_Security* default_instance_;
};
// -------------------------------------------------------------------

class Command_PinOperation : public ::google::protobuf::Message {
 public:
  Command_PinOperation();
  virtual ~Command_PinOperation();

  Command_PinOperation(const Command_PinOperation& from);

  inline Command_PinOperation& operator=(const Command_PinOperation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command_PinOperation& default_instance();

  void Swap(Command_PinOperation* other);

  // implements Message ----------------------------------------------

  Command_PinOperation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command_PinOperation& from);
  void MergeFrom(const Command_PinOperation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_PinOperation_PinOpType PinOpType;
  static const PinOpType INVALID_PINOP = Command_PinOperation_PinOpType_INVALID_PINOP;
  static const PinOpType UNLOCK_PINOP = Command_PinOperation_PinOpType_UNLOCK_PINOP;
  static const PinOpType LOCK_PINOP = Command_PinOperation_PinOpType_LOCK_PINOP;
  static const PinOpType ERASE_PINOP = Command_PinOperation_PinOpType_ERASE_PINOP;
  static const PinOpType SECURE_ERASE_PINOP = Command_PinOperation_PinOpType_SECURE_ERASE_PINOP;
  static inline bool PinOpType_IsValid(int value) {
    return Command_PinOperation_PinOpType_IsValid(value);
  }
  static const PinOpType PinOpType_MIN =
    Command_PinOperation_PinOpType_PinOpType_MIN;
  static const PinOpType PinOpType_MAX =
    Command_PinOperation_PinOpType_PinOpType_MAX;
  static const int PinOpType_ARRAYSIZE =
    Command_PinOperation_PinOpType_PinOpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PinOpType_descriptor() {
    return Command_PinOperation_PinOpType_descriptor();
  }
  static inline const ::std::string& PinOpType_Name(PinOpType value) {
    return Command_PinOperation_PinOpType_Name(value);
  }
  static inline bool PinOpType_Parse(const ::std::string& name,
      PinOpType* value) {
    return Command_PinOperation_PinOpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Command.PinOperation.PinOpType pinOpType = 1;
  inline bool has_pinoptype() const;
  inline void clear_pinoptype();
  static const int kPinOpTypeFieldNumber = 1;
  inline ::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType pinoptype() const;
  inline void set_pinoptype(::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType value);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command.PinOperation)
 private:
  inline void set_has_pinoptype();
  inline void clear_has_pinoptype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int pinoptype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command_PinOperation* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_Header Header;
  typedef Command_Body Body;
  typedef Command_Batch Batch;
  typedef Command_Status Status;
  typedef Command_KeyValue KeyValue;
  typedef Command_Range Range;
  typedef Command_Setup Setup;
  typedef Command_P2POperation P2POperation;
  typedef Command_GetLog GetLog;
  typedef Command_Security Security;
  typedef Command_PinOperation PinOperation;

  typedef Command_Synchronization Synchronization;
  static const Synchronization INVALID_SYNCHRONIZATION = Command_Synchronization_INVALID_SYNCHRONIZATION;
  static const Synchronization WRITETHROUGH = Command_Synchronization_WRITETHROUGH;
  static const Synchronization WRITEBACK = Command_Synchronization_WRITEBACK;
  static const Synchronization FLUSH = Command_Synchronization_FLUSH;
  static inline bool Synchronization_IsValid(int value) {
    return Command_Synchronization_IsValid(value);
  }
  static const Synchronization Synchronization_MIN =
    Command_Synchronization_Synchronization_MIN;
  static const Synchronization Synchronization_MAX =
    Command_Synchronization_Synchronization_MAX;
  static const int Synchronization_ARRAYSIZE =
    Command_Synchronization_Synchronization_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Synchronization_descriptor() {
    return Command_Synchronization_descriptor();
  }
  static inline const ::std::string& Synchronization_Name(Synchronization value) {
    return Command_Synchronization_Name(value);
  }
  static inline bool Synchronization_Parse(const ::std::string& name,
      Synchronization* value) {
    return Command_Synchronization_Parse(name, value);
  }

  typedef Command_Priority Priority;
  static const Priority NORMAL = Command_Priority_NORMAL;
  static const Priority LOWEST = Command_Priority_LOWEST;
  static const Priority LOWER = Command_Priority_LOWER;
  static const Priority HIGHER = Command_Priority_HIGHER;
  static const Priority HIGHEST = Command_Priority_HIGHEST;
  static inline bool Priority_IsValid(int value) {
    return Command_Priority_IsValid(value);
  }
  static const Priority Priority_MIN =
    Command_Priority_Priority_MIN;
  static const Priority Priority_MAX =
    Command_Priority_Priority_MAX;
  static const int Priority_ARRAYSIZE =
    Command_Priority_Priority_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Priority_descriptor() {
    return Command_Priority_descriptor();
  }
  static inline const ::std::string& Priority_Name(Priority value) {
    return Command_Priority_Name(value);
  }
  static inline bool Priority_Parse(const ::std::string& name,
      Priority* value) {
    return Command_Priority_Parse(name, value);
  }

  typedef Command_Algorithm Algorithm;
  static const Algorithm INVALID_ALGORITHM = Command_Algorithm_INVALID_ALGORITHM;
  static const Algorithm SHA1 = Command_Algorithm_SHA1;
  static const Algorithm SHA2 = Command_Algorithm_SHA2;
  static const Algorithm SHA3 = Command_Algorithm_SHA3;
  static const Algorithm CRC32 = Command_Algorithm_CRC32;
  static const Algorithm CRC64 = Command_Algorithm_CRC64;
  static inline bool Algorithm_IsValid(int value) {
    return Command_Algorithm_IsValid(value);
  }
  static const Algorithm Algorithm_MIN =
    Command_Algorithm_Algorithm_MIN;
  static const Algorithm Algorithm_MAX =
    Command_Algorithm_Algorithm_MAX;
  static const int Algorithm_ARRAYSIZE =
    Command_Algorithm_Algorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Algorithm_descriptor() {
    return Command_Algorithm_descriptor();
  }
  static inline const ::std::string& Algorithm_Name(Algorithm value) {
    return Command_Algorithm_Name(value);
  }
  static inline bool Algorithm_Parse(const ::std::string& name,
      Algorithm* value) {
    return Command_Algorithm_Parse(name, value);
  }

  typedef Command_MessageType MessageType;
  static const MessageType INVALID_MESSAGE_TYPE = Command_MessageType_INVALID_MESSAGE_TYPE;
  static const MessageType GET = Command_MessageType_GET;
  static const MessageType GET_RESPONSE = Command_MessageType_GET_RESPONSE;
  static const MessageType PUT = Command_MessageType_PUT;
  static const MessageType PUT_RESPONSE = Command_MessageType_PUT_RESPONSE;
  static const MessageType DELETE = Command_MessageType_DELETE;
  static const MessageType DELETE_RESPONSE = Command_MessageType_DELETE_RESPONSE;
  static const MessageType GETNEXT = Command_MessageType_GETNEXT;
  static const MessageType GETNEXT_RESPONSE = Command_MessageType_GETNEXT_RESPONSE;
  static const MessageType GETPREVIOUS = Command_MessageType_GETPREVIOUS;
  static const MessageType GETPREVIOUS_RESPONSE = Command_MessageType_GETPREVIOUS_RESPONSE;
  static const MessageType GETKEYRANGE = Command_MessageType_GETKEYRANGE;
  static const MessageType GETKEYRANGE_RESPONSE = Command_MessageType_GETKEYRANGE_RESPONSE;
  static const MessageType GETVERSION = Command_MessageType_GETVERSION;
  static const MessageType GETVERSION_RESPONSE = Command_MessageType_GETVERSION_RESPONSE;
  static const MessageType SETUP = Command_MessageType_SETUP;
  static const MessageType SETUP_RESPONSE = Command_MessageType_SETUP_RESPONSE;
  static const MessageType GETLOG = Command_MessageType_GETLOG;
  static const MessageType GETLOG_RESPONSE = Command_MessageType_GETLOG_RESPONSE;
  static const MessageType SECURITY = Command_MessageType_SECURITY;
  static const MessageType SECURITY_RESPONSE = Command_MessageType_SECURITY_RESPONSE;
  static const MessageType PEER2PEERPUSH = Command_MessageType_PEER2PEERPUSH;
  static const MessageType PEER2PEERPUSH_RESPONSE = Command_MessageType_PEER2PEERPUSH_RESPONSE;
  static const MessageType NOOP = Command_MessageType_NOOP;
  static const MessageType NOOP_RESPONSE = Command_MessageType_NOOP_RESPONSE;
  static const MessageType FLUSHALLDATA = Command_MessageType_FLUSHALLDATA;
  static const MessageType FLUSHALLDATA_RESPONSE = Command_MessageType_FLUSHALLDATA_RESPONSE;
  static const MessageType PINOP = Command_MessageType_PINOP;
  static const MessageType PINOP_RESPONSE = Command_MessageType_PINOP_RESPONSE;
  static const MessageType MEDIASCAN = Command_MessageType_MEDIASCAN;
  static const MessageType MEDIASCAN_RESPONSE = Command_MessageType_MEDIASCAN_RESPONSE;
  static const MessageType MEDIAOPTIMIZE = Command_MessageType_MEDIAOPTIMIZE;
  static const MessageType MEDIAOPTIMIZE_RESPONSE = Command_MessageType_MEDIAOPTIMIZE_RESPONSE;
  static const MessageType START_BATCH = Command_MessageType_START_BATCH;
  static const MessageType START_BATCH_RESPONSE = Command_MessageType_START_BATCH_RESPONSE;
  static const MessageType END_BATCH = Command_MessageType_END_BATCH;
  static const MessageType END_BATCH_RESPONSE = Command_MessageType_END_BATCH_RESPONSE;
  static const MessageType ABORT_BATCH = Command_MessageType_ABORT_BATCH;
  static const MessageType ABORT_BATCH_RESPONSE = Command_MessageType_ABORT_BATCH_RESPONSE;
  static inline bool MessageType_IsValid(int value) {
    return Command_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    Command_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    Command_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    Command_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return Command_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return Command_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return Command_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.seagate.kinetic.client.proto.Command.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::com::seagate::kinetic::client::proto::Command_Header& header() const;
  inline ::com::seagate::kinetic::client::proto::Command_Header* mutable_header();
  inline ::com::seagate::kinetic::client::proto::Command_Header* release_header();
  inline void set_allocated_header(::com::seagate::kinetic::client::proto::Command_Header* header);

  // optional .com.seagate.kinetic.client.proto.Command.Body body = 2;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::com::seagate::kinetic::client::proto::Command_Body& body() const;
  inline ::com::seagate::kinetic::client::proto::Command_Body* mutable_body();
  inline ::com::seagate::kinetic::client::proto::Command_Body* release_body();
  inline void set_allocated_body(::com::seagate::kinetic::client::proto::Command_Body* body);

  // optional .com.seagate.kinetic.client.proto.Command.Status status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::com::seagate::kinetic::client::proto::Command_Status& status() const;
  inline ::com::seagate::kinetic::client::proto::Command_Status* mutable_status();
  inline ::com::seagate::kinetic::client::proto::Command_Status* release_status();
  inline void set_allocated_status(::com::seagate::kinetic::client::proto::Command_Status* status);

  // @@protoc_insertion_point(class_scope:com.seagate.kinetic.client.proto.Command)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::seagate::kinetic::client::proto::Command_Header* header_;
  ::com::seagate::kinetic::client::proto::Command_Body* body_;
  ::com::seagate::kinetic::client::proto::Command_Status* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_kinetic_5fclient_2eproto();
  friend void protobuf_AssignDesc_kinetic_5fclient_2eproto();
  friend void protobuf_ShutdownFile_kinetic_5fclient_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// ===================================================================


// ===================================================================

// Local

// optional string protocolVersion = 1 [default = "3.0.6"];
inline bool Local::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Local::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Local::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Local::clear_protocolversion() {
  if (protocolversion_ != _default_protocolversion_) {
    protocolversion_->assign(*_default_protocolversion_);
  }
  clear_has_protocolversion();
}
inline const ::std::string& Local::protocolversion() const {
  return *protocolversion_;
}
inline void Local::set_protocolversion(const ::std::string& value) {
  set_has_protocolversion();
  if (protocolversion_ == _default_protocolversion_) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void Local::set_protocolversion(const char* value) {
  set_has_protocolversion();
  if (protocolversion_ == _default_protocolversion_) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void Local::set_protocolversion(const char* value, size_t size) {
  set_has_protocolversion();
  if (protocolversion_ == _default_protocolversion_) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Local::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == _default_protocolversion_) {
    protocolversion_ = new ::std::string(*_default_protocolversion_);
  }
  return protocolversion_;
}
inline ::std::string* Local::release_protocolversion() {
  clear_has_protocolversion();
  if (protocolversion_ == _default_protocolversion_) {
    return NULL;
  } else {
    ::std::string* temp = protocolversion_;
    protocolversion_ = const_cast< ::std::string*>(_default_protocolversion_);
    return temp;
  }
}
inline void Local::set_allocated_protocolversion(::std::string* protocolversion) {
  if (protocolversion_ != _default_protocolversion_) {
    delete protocolversion_;
  }
  if (protocolversion) {
    set_has_protocolversion();
    protocolversion_ = protocolversion;
  } else {
    clear_has_protocolversion();
    protocolversion_ = const_cast< ::std::string*>(_default_protocolversion_);
  }
}

// -------------------------------------------------------------------

// Message_HMACauth

// optional int64 identity = 1;
inline bool Message_HMACauth::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_HMACauth::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_HMACauth::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_HMACauth::clear_identity() {
  identity_ = GOOGLE_LONGLONG(0);
  clear_has_identity();
}
inline ::google::protobuf::int64 Message_HMACauth::identity() const {
  return identity_;
}
inline void Message_HMACauth::set_identity(::google::protobuf::int64 value) {
  set_has_identity();
  identity_ = value;
}

// optional bytes hmac = 2;
inline bool Message_HMACauth::has_hmac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message_HMACauth::set_has_hmac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message_HMACauth::clear_has_hmac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message_HMACauth::clear_hmac() {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    hmac_->clear();
  }
  clear_has_hmac();
}
inline const ::std::string& Message_HMACauth::hmac() const {
  return *hmac_;
}
inline void Message_HMACauth::set_hmac(const ::std::string& value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void Message_HMACauth::set_hmac(const char* value) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(value);
}
inline void Message_HMACauth::set_hmac(const void* value, size_t size) {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  hmac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_HMACauth::mutable_hmac() {
  set_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    hmac_ = new ::std::string;
  }
  return hmac_;
}
inline ::std::string* Message_HMACauth::release_hmac() {
  clear_has_hmac();
  if (hmac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hmac_;
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_HMACauth::set_allocated_hmac(::std::string* hmac) {
  if (hmac_ != &::google::protobuf::internal::kEmptyString) {
    delete hmac_;
  }
  if (hmac) {
    set_has_hmac();
    hmac_ = hmac;
  } else {
    clear_has_hmac();
    hmac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message_PINauth

// optional bytes pin = 1;
inline bool Message_PINauth::has_pin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message_PINauth::set_has_pin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message_PINauth::clear_has_pin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message_PINauth::clear_pin() {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    pin_->clear();
  }
  clear_has_pin();
}
inline const ::std::string& Message_PINauth::pin() const {
  return *pin_;
}
inline void Message_PINauth::set_pin(const ::std::string& value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void Message_PINauth::set_pin(const char* value) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(value);
}
inline void Message_PINauth::set_pin(const void* value, size_t size) {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  pin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message_PINauth::mutable_pin() {
  set_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    pin_ = new ::std::string;
  }
  return pin_;
}
inline ::std::string* Message_PINauth::release_pin() {
  clear_has_pin();
  if (pin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pin_;
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message_PINauth::set_allocated_pin(::std::string* pin) {
  if (pin_ != &::google::protobuf::internal::kEmptyString) {
    delete pin_;
  }
  if (pin) {
    set_has_pin();
    pin_ = pin;
  } else {
    clear_has_pin();
    pin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Message

// optional .com.seagate.kinetic.client.proto.Message.AuthType authType = 4;
inline bool Message::has_authtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_authtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_authtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_authtype() {
  authtype_ = -1;
  clear_has_authtype();
}
inline ::com::seagate::kinetic::client::proto::Message_AuthType Message::authtype() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Message_AuthType >(authtype_);
}
inline void Message::set_authtype(::com::seagate::kinetic::client::proto::Message_AuthType value) {
  assert(::com::seagate::kinetic::client::proto::Message_AuthType_IsValid(value));
  set_has_authtype();
  authtype_ = value;
}

// optional .com.seagate.kinetic.client.proto.Message.HMACauth hmacAuth = 5;
inline bool Message::has_hmacauth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_hmacauth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_hmacauth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_hmacauth() {
  if (hmacauth_ != NULL) hmacauth_->::com::seagate::kinetic::client::proto::Message_HMACauth::Clear();
  clear_has_hmacauth();
}
inline const ::com::seagate::kinetic::client::proto::Message_HMACauth& Message::hmacauth() const {
  return hmacauth_ != NULL ? *hmacauth_ : *default_instance_->hmacauth_;
}
inline ::com::seagate::kinetic::client::proto::Message_HMACauth* Message::mutable_hmacauth() {
  set_has_hmacauth();
  if (hmacauth_ == NULL) hmacauth_ = new ::com::seagate::kinetic::client::proto::Message_HMACauth;
  return hmacauth_;
}
inline ::com::seagate::kinetic::client::proto::Message_HMACauth* Message::release_hmacauth() {
  clear_has_hmacauth();
  ::com::seagate::kinetic::client::proto::Message_HMACauth* temp = hmacauth_;
  hmacauth_ = NULL;
  return temp;
}
inline void Message::set_allocated_hmacauth(::com::seagate::kinetic::client::proto::Message_HMACauth* hmacauth) {
  delete hmacauth_;
  hmacauth_ = hmacauth;
  if (hmacauth) {
    set_has_hmacauth();
  } else {
    clear_has_hmacauth();
  }
}

// optional .com.seagate.kinetic.client.proto.Message.PINauth pinAuth = 6;
inline bool Message::has_pinauth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_pinauth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_pinauth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_pinauth() {
  if (pinauth_ != NULL) pinauth_->::com::seagate::kinetic::client::proto::Message_PINauth::Clear();
  clear_has_pinauth();
}
inline const ::com::seagate::kinetic::client::proto::Message_PINauth& Message::pinauth() const {
  return pinauth_ != NULL ? *pinauth_ : *default_instance_->pinauth_;
}
inline ::com::seagate::kinetic::client::proto::Message_PINauth* Message::mutable_pinauth() {
  set_has_pinauth();
  if (pinauth_ == NULL) pinauth_ = new ::com::seagate::kinetic::client::proto::Message_PINauth;
  return pinauth_;
}
inline ::com::seagate::kinetic::client::proto::Message_PINauth* Message::release_pinauth() {
  clear_has_pinauth();
  ::com::seagate::kinetic::client::proto::Message_PINauth* temp = pinauth_;
  pinauth_ = NULL;
  return temp;
}
inline void Message::set_allocated_pinauth(::com::seagate::kinetic::client::proto::Message_PINauth* pinauth) {
  delete pinauth_;
  pinauth_ = pinauth;
  if (pinauth) {
    set_has_pinauth();
  } else {
    clear_has_pinauth();
  }
}

// optional bytes commandBytes = 7;
inline bool Message::has_commandbytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Message::set_has_commandbytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Message::clear_has_commandbytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Message::clear_commandbytes() {
  if (commandbytes_ != &::google::protobuf::internal::kEmptyString) {
    commandbytes_->clear();
  }
  clear_has_commandbytes();
}
inline const ::std::string& Message::commandbytes() const {
  return *commandbytes_;
}
inline void Message::set_commandbytes(const ::std::string& value) {
  set_has_commandbytes();
  if (commandbytes_ == &::google::protobuf::internal::kEmptyString) {
    commandbytes_ = new ::std::string;
  }
  commandbytes_->assign(value);
}
inline void Message::set_commandbytes(const char* value) {
  set_has_commandbytes();
  if (commandbytes_ == &::google::protobuf::internal::kEmptyString) {
    commandbytes_ = new ::std::string;
  }
  commandbytes_->assign(value);
}
inline void Message::set_commandbytes(const void* value, size_t size) {
  set_has_commandbytes();
  if (commandbytes_ == &::google::protobuf::internal::kEmptyString) {
    commandbytes_ = new ::std::string;
  }
  commandbytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Message::mutable_commandbytes() {
  set_has_commandbytes();
  if (commandbytes_ == &::google::protobuf::internal::kEmptyString) {
    commandbytes_ = new ::std::string;
  }
  return commandbytes_;
}
inline ::std::string* Message::release_commandbytes() {
  clear_has_commandbytes();
  if (commandbytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = commandbytes_;
    commandbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Message::set_allocated_commandbytes(::std::string* commandbytes) {
  if (commandbytes_ != &::google::protobuf::internal::kEmptyString) {
    delete commandbytes_;
  }
  if (commandbytes) {
    set_has_commandbytes();
    commandbytes_ = commandbytes;
  } else {
    clear_has_commandbytes();
    commandbytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command_Header

// optional int64 clusterVersion = 1;
inline bool Command_Header::has_clusterversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Header::set_has_clusterversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Header::clear_has_clusterversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Header::clear_clusterversion() {
  clusterversion_ = GOOGLE_LONGLONG(0);
  clear_has_clusterversion();
}
inline ::google::protobuf::int64 Command_Header::clusterversion() const {
  return clusterversion_;
}
inline void Command_Header::set_clusterversion(::google::protobuf::int64 value) {
  set_has_clusterversion();
  clusterversion_ = value;
}

// optional int64 connectionID = 3;
inline bool Command_Header::has_connectionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Header::set_has_connectionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Header::clear_has_connectionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Header::clear_connectionid() {
  connectionid_ = GOOGLE_LONGLONG(0);
  clear_has_connectionid();
}
inline ::google::protobuf::int64 Command_Header::connectionid() const {
  return connectionid_;
}
inline void Command_Header::set_connectionid(::google::protobuf::int64 value) {
  set_has_connectionid();
  connectionid_ = value;
}

// optional int64 sequence = 4;
inline bool Command_Header::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Header::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Header::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Header::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::int64 Command_Header::sequence() const {
  return sequence_;
}
inline void Command_Header::set_sequence(::google::protobuf::int64 value) {
  set_has_sequence();
  sequence_ = value;
}

// optional int64 ackSequence = 6;
inline bool Command_Header::has_acksequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_Header::set_has_acksequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_Header::clear_has_acksequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_Header::clear_acksequence() {
  acksequence_ = GOOGLE_LONGLONG(0);
  clear_has_acksequence();
}
inline ::google::protobuf::int64 Command_Header::acksequence() const {
  return acksequence_;
}
inline void Command_Header::set_acksequence(::google::protobuf::int64 value) {
  set_has_acksequence();
  acksequence_ = value;
}

// optional .com.seagate.kinetic.client.proto.Command.MessageType messageType = 7;
inline bool Command_Header::has_messagetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_Header::set_has_messagetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_Header::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_Header::clear_messagetype() {
  messagetype_ = -1;
  clear_has_messagetype();
}
inline ::com::seagate::kinetic::client::proto::Command_MessageType Command_Header::messagetype() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_MessageType >(messagetype_);
}
inline void Command_Header::set_messagetype(::com::seagate::kinetic::client::proto::Command_MessageType value) {
  assert(::com::seagate::kinetic::client::proto::Command_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional int64 timeout = 9;
inline bool Command_Header::has_timeout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_Header::set_has_timeout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_Header::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_Header::clear_timeout() {
  timeout_ = GOOGLE_LONGLONG(0);
  clear_has_timeout();
}
inline ::google::protobuf::int64 Command_Header::timeout() const {
  return timeout_;
}
inline void Command_Header::set_timeout(::google::protobuf::int64 value) {
  set_has_timeout();
  timeout_ = value;
}

// optional bool earlyExit = 10;
inline bool Command_Header::has_earlyexit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command_Header::set_has_earlyexit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command_Header::clear_has_earlyexit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command_Header::clear_earlyexit() {
  earlyexit_ = false;
  clear_has_earlyexit();
}
inline bool Command_Header::earlyexit() const {
  return earlyexit_;
}
inline void Command_Header::set_earlyexit(bool value) {
  set_has_earlyexit();
  earlyexit_ = value;
}

// optional .com.seagate.kinetic.client.proto.Command.Priority priority = 12;
inline bool Command_Header::has_priority() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command_Header::set_has_priority() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command_Header::clear_has_priority() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command_Header::clear_priority() {
  priority_ = 5;
  clear_has_priority();
}
inline ::com::seagate::kinetic::client::proto::Command_Priority Command_Header::priority() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Priority >(priority_);
}
inline void Command_Header::set_priority(::com::seagate::kinetic::client::proto::Command_Priority value) {
  assert(::com::seagate::kinetic::client::proto::Command_Priority_IsValid(value));
  set_has_priority();
  priority_ = value;
}

// optional int64 TimeQuanta = 13;
inline bool Command_Header::has_timequanta() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command_Header::set_has_timequanta() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command_Header::clear_has_timequanta() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command_Header::clear_timequanta() {
  timequanta_ = GOOGLE_LONGLONG(0);
  clear_has_timequanta();
}
inline ::google::protobuf::int64 Command_Header::timequanta() const {
  return timequanta_;
}
inline void Command_Header::set_timequanta(::google::protobuf::int64 value) {
  set_has_timequanta();
  timequanta_ = value;
}

// optional uint32 batchID = 14;
inline bool Command_Header::has_batchid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command_Header::set_has_batchid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command_Header::clear_has_batchid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command_Header::clear_batchid() {
  batchid_ = 0u;
  clear_has_batchid();
}
inline ::google::protobuf::uint32 Command_Header::batchid() const {
  return batchid_;
}
inline void Command_Header::set_batchid(::google::protobuf::uint32 value) {
  set_has_batchid();
  batchid_ = value;
}

// -------------------------------------------------------------------

// Command_Body

// optional .com.seagate.kinetic.client.proto.Command.KeyValue keyValue = 1;
inline bool Command_Body::has_keyvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Body::set_has_keyvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Body::clear_has_keyvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Body::clear_keyvalue() {
  if (keyvalue_ != NULL) keyvalue_->::com::seagate::kinetic::client::proto::Command_KeyValue::Clear();
  clear_has_keyvalue();
}
inline const ::com::seagate::kinetic::client::proto::Command_KeyValue& Command_Body::keyvalue() const {
  return keyvalue_ != NULL ? *keyvalue_ : *default_instance_->keyvalue_;
}
inline ::com::seagate::kinetic::client::proto::Command_KeyValue* Command_Body::mutable_keyvalue() {
  set_has_keyvalue();
  if (keyvalue_ == NULL) keyvalue_ = new ::com::seagate::kinetic::client::proto::Command_KeyValue;
  return keyvalue_;
}
inline ::com::seagate::kinetic::client::proto::Command_KeyValue* Command_Body::release_keyvalue() {
  clear_has_keyvalue();
  ::com::seagate::kinetic::client::proto::Command_KeyValue* temp = keyvalue_;
  keyvalue_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_keyvalue(::com::seagate::kinetic::client::proto::Command_KeyValue* keyvalue) {
  delete keyvalue_;
  keyvalue_ = keyvalue;
  if (keyvalue) {
    set_has_keyvalue();
  } else {
    clear_has_keyvalue();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Range range = 2;
inline bool Command_Body::has_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Body::set_has_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Body::clear_has_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Body::clear_range() {
  if (range_ != NULL) range_->::com::seagate::kinetic::client::proto::Command_Range::Clear();
  clear_has_range();
}
inline const ::com::seagate::kinetic::client::proto::Command_Range& Command_Body::range() const {
  return range_ != NULL ? *range_ : *default_instance_->range_;
}
inline ::com::seagate::kinetic::client::proto::Command_Range* Command_Body::mutable_range() {
  set_has_range();
  if (range_ == NULL) range_ = new ::com::seagate::kinetic::client::proto::Command_Range;
  return range_;
}
inline ::com::seagate::kinetic::client::proto::Command_Range* Command_Body::release_range() {
  clear_has_range();
  ::com::seagate::kinetic::client::proto::Command_Range* temp = range_;
  range_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_range(::com::seagate::kinetic::client::proto::Command_Range* range) {
  delete range_;
  range_ = range;
  if (range) {
    set_has_range();
  } else {
    clear_has_range();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Setup setup = 3;
inline bool Command_Body::has_setup() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Body::set_has_setup() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Body::clear_has_setup() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Body::clear_setup() {
  if (setup_ != NULL) setup_->::com::seagate::kinetic::client::proto::Command_Setup::Clear();
  clear_has_setup();
}
inline const ::com::seagate::kinetic::client::proto::Command_Setup& Command_Body::setup() const {
  return setup_ != NULL ? *setup_ : *default_instance_->setup_;
}
inline ::com::seagate::kinetic::client::proto::Command_Setup* Command_Body::mutable_setup() {
  set_has_setup();
  if (setup_ == NULL) setup_ = new ::com::seagate::kinetic::client::proto::Command_Setup;
  return setup_;
}
inline ::com::seagate::kinetic::client::proto::Command_Setup* Command_Body::release_setup() {
  clear_has_setup();
  ::com::seagate::kinetic::client::proto::Command_Setup* temp = setup_;
  setup_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_setup(::com::seagate::kinetic::client::proto::Command_Setup* setup) {
  delete setup_;
  setup_ = setup;
  if (setup) {
    set_has_setup();
  } else {
    clear_has_setup();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.P2POperation p2pOperation = 4;
inline bool Command_Body::has_p2poperation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_Body::set_has_p2poperation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_Body::clear_has_p2poperation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_Body::clear_p2poperation() {
  if (p2poperation_ != NULL) p2poperation_->::com::seagate::kinetic::client::proto::Command_P2POperation::Clear();
  clear_has_p2poperation();
}
inline const ::com::seagate::kinetic::client::proto::Command_P2POperation& Command_Body::p2poperation() const {
  return p2poperation_ != NULL ? *p2poperation_ : *default_instance_->p2poperation_;
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation* Command_Body::mutable_p2poperation() {
  set_has_p2poperation();
  if (p2poperation_ == NULL) p2poperation_ = new ::com::seagate::kinetic::client::proto::Command_P2POperation;
  return p2poperation_;
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation* Command_Body::release_p2poperation() {
  clear_has_p2poperation();
  ::com::seagate::kinetic::client::proto::Command_P2POperation* temp = p2poperation_;
  p2poperation_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_p2poperation(::com::seagate::kinetic::client::proto::Command_P2POperation* p2poperation) {
  delete p2poperation_;
  p2poperation_ = p2poperation;
  if (p2poperation) {
    set_has_p2poperation();
  } else {
    clear_has_p2poperation();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.GetLog getLog = 6;
inline bool Command_Body::has_getlog() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_Body::set_has_getlog() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_Body::clear_has_getlog() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_Body::clear_getlog() {
  if (getlog_ != NULL) getlog_->::com::seagate::kinetic::client::proto::Command_GetLog::Clear();
  clear_has_getlog();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog& Command_Body::getlog() const {
  return getlog_ != NULL ? *getlog_ : *default_instance_->getlog_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog* Command_Body::mutable_getlog() {
  set_has_getlog();
  if (getlog_ == NULL) getlog_ = new ::com::seagate::kinetic::client::proto::Command_GetLog;
  return getlog_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog* Command_Body::release_getlog() {
  clear_has_getlog();
  ::com::seagate::kinetic::client::proto::Command_GetLog* temp = getlog_;
  getlog_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_getlog(::com::seagate::kinetic::client::proto::Command_GetLog* getlog) {
  delete getlog_;
  getlog_ = getlog;
  if (getlog) {
    set_has_getlog();
  } else {
    clear_has_getlog();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Security security = 7;
inline bool Command_Body::has_security() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_Body::set_has_security() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_Body::clear_has_security() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_Body::clear_security() {
  if (security_ != NULL) security_->::com::seagate::kinetic::client::proto::Command_Security::Clear();
  clear_has_security();
}
inline const ::com::seagate::kinetic::client::proto::Command_Security& Command_Body::security() const {
  return security_ != NULL ? *security_ : *default_instance_->security_;
}
inline ::com::seagate::kinetic::client::proto::Command_Security* Command_Body::mutable_security() {
  set_has_security();
  if (security_ == NULL) security_ = new ::com::seagate::kinetic::client::proto::Command_Security;
  return security_;
}
inline ::com::seagate::kinetic::client::proto::Command_Security* Command_Body::release_security() {
  clear_has_security();
  ::com::seagate::kinetic::client::proto::Command_Security* temp = security_;
  security_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_security(::com::seagate::kinetic::client::proto::Command_Security* security) {
  delete security_;
  security_ = security;
  if (security) {
    set_has_security();
  } else {
    clear_has_security();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.PinOperation pinOp = 8;
inline bool Command_Body::has_pinop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command_Body::set_has_pinop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command_Body::clear_has_pinop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command_Body::clear_pinop() {
  if (pinop_ != NULL) pinop_->::com::seagate::kinetic::client::proto::Command_PinOperation::Clear();
  clear_has_pinop();
}
inline const ::com::seagate::kinetic::client::proto::Command_PinOperation& Command_Body::pinop() const {
  return pinop_ != NULL ? *pinop_ : *default_instance_->pinop_;
}
inline ::com::seagate::kinetic::client::proto::Command_PinOperation* Command_Body::mutable_pinop() {
  set_has_pinop();
  if (pinop_ == NULL) pinop_ = new ::com::seagate::kinetic::client::proto::Command_PinOperation;
  return pinop_;
}
inline ::com::seagate::kinetic::client::proto::Command_PinOperation* Command_Body::release_pinop() {
  clear_has_pinop();
  ::com::seagate::kinetic::client::proto::Command_PinOperation* temp = pinop_;
  pinop_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_pinop(::com::seagate::kinetic::client::proto::Command_PinOperation* pinop) {
  delete pinop_;
  pinop_ = pinop;
  if (pinop) {
    set_has_pinop();
  } else {
    clear_has_pinop();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Batch batch = 9;
inline bool Command_Body::has_batch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command_Body::set_has_batch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command_Body::clear_has_batch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command_Body::clear_batch() {
  if (batch_ != NULL) batch_->::com::seagate::kinetic::client::proto::Command_Batch::Clear();
  clear_has_batch();
}
inline const ::com::seagate::kinetic::client::proto::Command_Batch& Command_Body::batch() const {
  return batch_ != NULL ? *batch_ : *default_instance_->batch_;
}
inline ::com::seagate::kinetic::client::proto::Command_Batch* Command_Body::mutable_batch() {
  set_has_batch();
  if (batch_ == NULL) batch_ = new ::com::seagate::kinetic::client::proto::Command_Batch;
  return batch_;
}
inline ::com::seagate::kinetic::client::proto::Command_Batch* Command_Body::release_batch() {
  clear_has_batch();
  ::com::seagate::kinetic::client::proto::Command_Batch* temp = batch_;
  batch_ = NULL;
  return temp;
}
inline void Command_Body::set_allocated_batch(::com::seagate::kinetic::client::proto::Command_Batch* batch) {
  delete batch_;
  batch_ = batch;
  if (batch) {
    set_has_batch();
  } else {
    clear_has_batch();
  }
}

// -------------------------------------------------------------------

// Command_Batch

// optional int32 count = 1;
inline bool Command_Batch::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Batch::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Batch::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Batch::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 Command_Batch::count() const {
  return count_;
}
inline void Command_Batch::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// repeated int64 sequence = 2 [packed = true];
inline int Command_Batch::sequence_size() const {
  return sequence_.size();
}
inline void Command_Batch::clear_sequence() {
  sequence_.Clear();
}
inline ::google::protobuf::int64 Command_Batch::sequence(int index) const {
  return sequence_.Get(index);
}
inline void Command_Batch::set_sequence(int index, ::google::protobuf::int64 value) {
  sequence_.Set(index, value);
}
inline void Command_Batch::add_sequence(::google::protobuf::int64 value) {
  sequence_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
Command_Batch::sequence() const {
  return sequence_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
Command_Batch::mutable_sequence() {
  return &sequence_;
}

// optional int64 failedSequence = 3;
inline bool Command_Batch::has_failedsequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Batch::set_has_failedsequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Batch::clear_has_failedsequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Batch::clear_failedsequence() {
  failedsequence_ = GOOGLE_LONGLONG(0);
  clear_has_failedsequence();
}
inline ::google::protobuf::int64 Command_Batch::failedsequence() const {
  return failedsequence_;
}
inline void Command_Batch::set_failedsequence(::google::protobuf::int64 value) {
  set_has_failedsequence();
  failedsequence_ = value;
}

// -------------------------------------------------------------------

// Command_Status

// optional .com.seagate.kinetic.client.proto.Command.Status.StatusCode code = 1;
inline bool Command_Status::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Status::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Status::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Status::clear_code() {
  code_ = -1;
  clear_has_code();
}
inline ::com::seagate::kinetic::client::proto::Command_Status_StatusCode Command_Status::code() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Status_StatusCode >(code_);
}
inline void Command_Status::set_code(::com::seagate::kinetic::client::proto::Command_Status_StatusCode value) {
  assert(::com::seagate::kinetic::client::proto::Command_Status_StatusCode_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string statusMessage = 2;
inline bool Command_Status::has_statusmessage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Status::set_has_statusmessage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Status::clear_has_statusmessage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Status::clear_statusmessage() {
  if (statusmessage_ != &::google::protobuf::internal::kEmptyString) {
    statusmessage_->clear();
  }
  clear_has_statusmessage();
}
inline const ::std::string& Command_Status::statusmessage() const {
  return *statusmessage_;
}
inline void Command_Status::set_statusmessage(const ::std::string& value) {
  set_has_statusmessage();
  if (statusmessage_ == &::google::protobuf::internal::kEmptyString) {
    statusmessage_ = new ::std::string;
  }
  statusmessage_->assign(value);
}
inline void Command_Status::set_statusmessage(const char* value) {
  set_has_statusmessage();
  if (statusmessage_ == &::google::protobuf::internal::kEmptyString) {
    statusmessage_ = new ::std::string;
  }
  statusmessage_->assign(value);
}
inline void Command_Status::set_statusmessage(const char* value, size_t size) {
  set_has_statusmessage();
  if (statusmessage_ == &::google::protobuf::internal::kEmptyString) {
    statusmessage_ = new ::std::string;
  }
  statusmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Status::mutable_statusmessage() {
  set_has_statusmessage();
  if (statusmessage_ == &::google::protobuf::internal::kEmptyString) {
    statusmessage_ = new ::std::string;
  }
  return statusmessage_;
}
inline ::std::string* Command_Status::release_statusmessage() {
  clear_has_statusmessage();
  if (statusmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statusmessage_;
    statusmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Status::set_allocated_statusmessage(::std::string* statusmessage) {
  if (statusmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete statusmessage_;
  }
  if (statusmessage) {
    set_has_statusmessage();
    statusmessage_ = statusmessage;
  } else {
    clear_has_statusmessage();
    statusmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes detailedMessage = 3;
inline bool Command_Status::has_detailedmessage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Status::set_has_detailedmessage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Status::clear_has_detailedmessage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Status::clear_detailedmessage() {
  if (detailedmessage_ != &::google::protobuf::internal::kEmptyString) {
    detailedmessage_->clear();
  }
  clear_has_detailedmessage();
}
inline const ::std::string& Command_Status::detailedmessage() const {
  return *detailedmessage_;
}
inline void Command_Status::set_detailedmessage(const ::std::string& value) {
  set_has_detailedmessage();
  if (detailedmessage_ == &::google::protobuf::internal::kEmptyString) {
    detailedmessage_ = new ::std::string;
  }
  detailedmessage_->assign(value);
}
inline void Command_Status::set_detailedmessage(const char* value) {
  set_has_detailedmessage();
  if (detailedmessage_ == &::google::protobuf::internal::kEmptyString) {
    detailedmessage_ = new ::std::string;
  }
  detailedmessage_->assign(value);
}
inline void Command_Status::set_detailedmessage(const void* value, size_t size) {
  set_has_detailedmessage();
  if (detailedmessage_ == &::google::protobuf::internal::kEmptyString) {
    detailedmessage_ = new ::std::string;
  }
  detailedmessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Status::mutable_detailedmessage() {
  set_has_detailedmessage();
  if (detailedmessage_ == &::google::protobuf::internal::kEmptyString) {
    detailedmessage_ = new ::std::string;
  }
  return detailedmessage_;
}
inline ::std::string* Command_Status::release_detailedmessage() {
  clear_has_detailedmessage();
  if (detailedmessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = detailedmessage_;
    detailedmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Status::set_allocated_detailedmessage(::std::string* detailedmessage) {
  if (detailedmessage_ != &::google::protobuf::internal::kEmptyString) {
    delete detailedmessage_;
  }
  if (detailedmessage) {
    set_has_detailedmessage();
    detailedmessage_ = detailedmessage;
  } else {
    clear_has_detailedmessage();
    detailedmessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command_KeyValue

// optional bytes newVersion = 2;
inline bool Command_KeyValue::has_newversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_KeyValue::set_has_newversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_KeyValue::clear_has_newversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_KeyValue::clear_newversion() {
  if (newversion_ != &::google::protobuf::internal::kEmptyString) {
    newversion_->clear();
  }
  clear_has_newversion();
}
inline const ::std::string& Command_KeyValue::newversion() const {
  return *newversion_;
}
inline void Command_KeyValue::set_newversion(const ::std::string& value) {
  set_has_newversion();
  if (newversion_ == &::google::protobuf::internal::kEmptyString) {
    newversion_ = new ::std::string;
  }
  newversion_->assign(value);
}
inline void Command_KeyValue::set_newversion(const char* value) {
  set_has_newversion();
  if (newversion_ == &::google::protobuf::internal::kEmptyString) {
    newversion_ = new ::std::string;
  }
  newversion_->assign(value);
}
inline void Command_KeyValue::set_newversion(const void* value, size_t size) {
  set_has_newversion();
  if (newversion_ == &::google::protobuf::internal::kEmptyString) {
    newversion_ = new ::std::string;
  }
  newversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_KeyValue::mutable_newversion() {
  set_has_newversion();
  if (newversion_ == &::google::protobuf::internal::kEmptyString) {
    newversion_ = new ::std::string;
  }
  return newversion_;
}
inline ::std::string* Command_KeyValue::release_newversion() {
  clear_has_newversion();
  if (newversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newversion_;
    newversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_KeyValue::set_allocated_newversion(::std::string* newversion) {
  if (newversion_ != &::google::protobuf::internal::kEmptyString) {
    delete newversion_;
  }
  if (newversion) {
    set_has_newversion();
    newversion_ = newversion;
  } else {
    clear_has_newversion();
    newversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool force = 8;
inline bool Command_KeyValue::has_force() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_KeyValue::set_has_force() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_KeyValue::clear_has_force() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_KeyValue::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool Command_KeyValue::force() const {
  return force_;
}
inline void Command_KeyValue::set_force(bool value) {
  set_has_force();
  force_ = value;
}

// optional bytes key = 3;
inline bool Command_KeyValue::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_KeyValue::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_KeyValue::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_KeyValue::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Command_KeyValue::key() const {
  return *key_;
}
inline void Command_KeyValue::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Command_KeyValue::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Command_KeyValue::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_KeyValue::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Command_KeyValue::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_KeyValue::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes dbVersion = 4;
inline bool Command_KeyValue::has_dbversion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_KeyValue::set_has_dbversion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_KeyValue::clear_has_dbversion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_KeyValue::clear_dbversion() {
  if (dbversion_ != &::google::protobuf::internal::kEmptyString) {
    dbversion_->clear();
  }
  clear_has_dbversion();
}
inline const ::std::string& Command_KeyValue::dbversion() const {
  return *dbversion_;
}
inline void Command_KeyValue::set_dbversion(const ::std::string& value) {
  set_has_dbversion();
  if (dbversion_ == &::google::protobuf::internal::kEmptyString) {
    dbversion_ = new ::std::string;
  }
  dbversion_->assign(value);
}
inline void Command_KeyValue::set_dbversion(const char* value) {
  set_has_dbversion();
  if (dbversion_ == &::google::protobuf::internal::kEmptyString) {
    dbversion_ = new ::std::string;
  }
  dbversion_->assign(value);
}
inline void Command_KeyValue::set_dbversion(const void* value, size_t size) {
  set_has_dbversion();
  if (dbversion_ == &::google::protobuf::internal::kEmptyString) {
    dbversion_ = new ::std::string;
  }
  dbversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_KeyValue::mutable_dbversion() {
  set_has_dbversion();
  if (dbversion_ == &::google::protobuf::internal::kEmptyString) {
    dbversion_ = new ::std::string;
  }
  return dbversion_;
}
inline ::std::string* Command_KeyValue::release_dbversion() {
  clear_has_dbversion();
  if (dbversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dbversion_;
    dbversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_KeyValue::set_allocated_dbversion(::std::string* dbversion) {
  if (dbversion_ != &::google::protobuf::internal::kEmptyString) {
    delete dbversion_;
  }
  if (dbversion) {
    set_has_dbversion();
    dbversion_ = dbversion;
  } else {
    clear_has_dbversion();
    dbversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes tag = 5;
inline bool Command_KeyValue::has_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_KeyValue::set_has_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_KeyValue::clear_has_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_KeyValue::clear_tag() {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    tag_->clear();
  }
  clear_has_tag();
}
inline const ::std::string& Command_KeyValue::tag() const {
  return *tag_;
}
inline void Command_KeyValue::set_tag(const ::std::string& value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Command_KeyValue::set_tag(const char* value) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(value);
}
inline void Command_KeyValue::set_tag(const void* value, size_t size) {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_KeyValue::mutable_tag() {
  set_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    tag_ = new ::std::string;
  }
  return tag_;
}
inline ::std::string* Command_KeyValue::release_tag() {
  clear_has_tag();
  if (tag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tag_;
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_KeyValue::set_allocated_tag(::std::string* tag) {
  if (tag_ != &::google::protobuf::internal::kEmptyString) {
    delete tag_;
  }
  if (tag) {
    set_has_tag();
    tag_ = tag;
  } else {
    clear_has_tag();
    tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Algorithm algorithm = 6;
inline bool Command_KeyValue::has_algorithm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_KeyValue::set_has_algorithm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_KeyValue::clear_has_algorithm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_KeyValue::clear_algorithm() {
  algorithm_ = -1;
  clear_has_algorithm();
}
inline ::com::seagate::kinetic::client::proto::Command_Algorithm Command_KeyValue::algorithm() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Algorithm >(algorithm_);
}
inline void Command_KeyValue::set_algorithm(::com::seagate::kinetic::client::proto::Command_Algorithm value) {
  assert(::com::seagate::kinetic::client::proto::Command_Algorithm_IsValid(value));
  set_has_algorithm();
  algorithm_ = value;
}

// optional bool metadataOnly = 7;
inline bool Command_KeyValue::has_metadataonly() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command_KeyValue::set_has_metadataonly() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command_KeyValue::clear_has_metadataonly() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command_KeyValue::clear_metadataonly() {
  metadataonly_ = false;
  clear_has_metadataonly();
}
inline bool Command_KeyValue::metadataonly() const {
  return metadataonly_;
}
inline void Command_KeyValue::set_metadataonly(bool value) {
  set_has_metadataonly();
  metadataonly_ = value;
}

// optional .com.seagate.kinetic.client.proto.Command.Synchronization synchronization = 9;
inline bool Command_KeyValue::has_synchronization() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command_KeyValue::set_has_synchronization() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command_KeyValue::clear_has_synchronization() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command_KeyValue::clear_synchronization() {
  synchronization_ = -1;
  clear_has_synchronization();
}
inline ::com::seagate::kinetic::client::proto::Command_Synchronization Command_KeyValue::synchronization() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Synchronization >(synchronization_);
}
inline void Command_KeyValue::set_synchronization(::com::seagate::kinetic::client::proto::Command_Synchronization value) {
  assert(::com::seagate::kinetic::client::proto::Command_Synchronization_IsValid(value));
  set_has_synchronization();
  synchronization_ = value;
}

// -------------------------------------------------------------------

// Command_Range

// optional bytes startKey = 1;
inline bool Command_Range::has_startkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Range::set_has_startkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Range::clear_has_startkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Range::clear_startkey() {
  if (startkey_ != &::google::protobuf::internal::kEmptyString) {
    startkey_->clear();
  }
  clear_has_startkey();
}
inline const ::std::string& Command_Range::startkey() const {
  return *startkey_;
}
inline void Command_Range::set_startkey(const ::std::string& value) {
  set_has_startkey();
  if (startkey_ == &::google::protobuf::internal::kEmptyString) {
    startkey_ = new ::std::string;
  }
  startkey_->assign(value);
}
inline void Command_Range::set_startkey(const char* value) {
  set_has_startkey();
  if (startkey_ == &::google::protobuf::internal::kEmptyString) {
    startkey_ = new ::std::string;
  }
  startkey_->assign(value);
}
inline void Command_Range::set_startkey(const void* value, size_t size) {
  set_has_startkey();
  if (startkey_ == &::google::protobuf::internal::kEmptyString) {
    startkey_ = new ::std::string;
  }
  startkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Range::mutable_startkey() {
  set_has_startkey();
  if (startkey_ == &::google::protobuf::internal::kEmptyString) {
    startkey_ = new ::std::string;
  }
  return startkey_;
}
inline ::std::string* Command_Range::release_startkey() {
  clear_has_startkey();
  if (startkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startkey_;
    startkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Range::set_allocated_startkey(::std::string* startkey) {
  if (startkey_ != &::google::protobuf::internal::kEmptyString) {
    delete startkey_;
  }
  if (startkey) {
    set_has_startkey();
    startkey_ = startkey;
  } else {
    clear_has_startkey();
    startkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes endKey = 2;
inline bool Command_Range::has_endkey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Range::set_has_endkey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Range::clear_has_endkey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Range::clear_endkey() {
  if (endkey_ != &::google::protobuf::internal::kEmptyString) {
    endkey_->clear();
  }
  clear_has_endkey();
}
inline const ::std::string& Command_Range::endkey() const {
  return *endkey_;
}
inline void Command_Range::set_endkey(const ::std::string& value) {
  set_has_endkey();
  if (endkey_ == &::google::protobuf::internal::kEmptyString) {
    endkey_ = new ::std::string;
  }
  endkey_->assign(value);
}
inline void Command_Range::set_endkey(const char* value) {
  set_has_endkey();
  if (endkey_ == &::google::protobuf::internal::kEmptyString) {
    endkey_ = new ::std::string;
  }
  endkey_->assign(value);
}
inline void Command_Range::set_endkey(const void* value, size_t size) {
  set_has_endkey();
  if (endkey_ == &::google::protobuf::internal::kEmptyString) {
    endkey_ = new ::std::string;
  }
  endkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Range::mutable_endkey() {
  set_has_endkey();
  if (endkey_ == &::google::protobuf::internal::kEmptyString) {
    endkey_ = new ::std::string;
  }
  return endkey_;
}
inline ::std::string* Command_Range::release_endkey() {
  clear_has_endkey();
  if (endkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endkey_;
    endkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Range::set_allocated_endkey(::std::string* endkey) {
  if (endkey_ != &::google::protobuf::internal::kEmptyString) {
    delete endkey_;
  }
  if (endkey) {
    set_has_endkey();
    endkey_ = endkey;
  } else {
    clear_has_endkey();
    endkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool startKeyInclusive = 3;
inline bool Command_Range::has_startkeyinclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Range::set_has_startkeyinclusive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Range::clear_has_startkeyinclusive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Range::clear_startkeyinclusive() {
  startkeyinclusive_ = false;
  clear_has_startkeyinclusive();
}
inline bool Command_Range::startkeyinclusive() const {
  return startkeyinclusive_;
}
inline void Command_Range::set_startkeyinclusive(bool value) {
  set_has_startkeyinclusive();
  startkeyinclusive_ = value;
}

// optional bool endKeyInclusive = 4;
inline bool Command_Range::has_endkeyinclusive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_Range::set_has_endkeyinclusive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_Range::clear_has_endkeyinclusive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_Range::clear_endkeyinclusive() {
  endkeyinclusive_ = false;
  clear_has_endkeyinclusive();
}
inline bool Command_Range::endkeyinclusive() const {
  return endkeyinclusive_;
}
inline void Command_Range::set_endkeyinclusive(bool value) {
  set_has_endkeyinclusive();
  endkeyinclusive_ = value;
}

// optional int32 maxReturned = 5;
inline bool Command_Range::has_maxreturned() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_Range::set_has_maxreturned() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_Range::clear_has_maxreturned() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_Range::clear_maxreturned() {
  maxreturned_ = 0;
  clear_has_maxreturned();
}
inline ::google::protobuf::int32 Command_Range::maxreturned() const {
  return maxreturned_;
}
inline void Command_Range::set_maxreturned(::google::protobuf::int32 value) {
  set_has_maxreturned();
  maxreturned_ = value;
}

// optional bool reverse = 6;
inline bool Command_Range::has_reverse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_Range::set_has_reverse() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_Range::clear_has_reverse() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_Range::clear_reverse() {
  reverse_ = false;
  clear_has_reverse();
}
inline bool Command_Range::reverse() const {
  return reverse_;
}
inline void Command_Range::set_reverse(bool value) {
  set_has_reverse();
  reverse_ = value;
}

// repeated bytes keys = 8;
inline int Command_Range::keys_size() const {
  return keys_.size();
}
inline void Command_Range::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& Command_Range::keys(int index) const {
  return keys_.Get(index);
}
inline ::std::string* Command_Range::mutable_keys(int index) {
  return keys_.Mutable(index);
}
inline void Command_Range::set_keys(int index, const ::std::string& value) {
  keys_.Mutable(index)->assign(value);
}
inline void Command_Range::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
}
inline void Command_Range::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Range::add_keys() {
  return keys_.Add();
}
inline void Command_Range::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
}
inline void Command_Range::add_keys(const char* value) {
  keys_.Add()->assign(value);
}
inline void Command_Range::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Command_Range::keys() const {
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Command_Range::mutable_keys() {
  return &keys_;
}

// -------------------------------------------------------------------

// Command_Setup

// optional int64 newClusterVersion = 1;
inline bool Command_Setup::has_newclusterversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Setup::set_has_newclusterversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Setup::clear_has_newclusterversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Setup::clear_newclusterversion() {
  newclusterversion_ = GOOGLE_LONGLONG(0);
  clear_has_newclusterversion();
}
inline ::google::protobuf::int64 Command_Setup::newclusterversion() const {
  return newclusterversion_;
}
inline void Command_Setup::set_newclusterversion(::google::protobuf::int64 value) {
  set_has_newclusterversion();
  newclusterversion_ = value;
}

// optional bool firmwareDownload = 5;
inline bool Command_Setup::has_firmwaredownload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Setup::set_has_firmwaredownload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Setup::clear_has_firmwaredownload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Setup::clear_firmwaredownload() {
  firmwaredownload_ = false;
  clear_has_firmwaredownload();
}
inline bool Command_Setup::firmwaredownload() const {
  return firmwaredownload_;
}
inline void Command_Setup::set_firmwaredownload(bool value) {
  set_has_firmwaredownload();
  firmwaredownload_ = value;
}

// -------------------------------------------------------------------

// Command_P2POperation_Operation

// optional bytes key = 3;
inline bool Command_P2POperation_Operation::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_P2POperation_Operation::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_P2POperation_Operation::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_P2POperation_Operation::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Command_P2POperation_Operation::key() const {
  return *key_;
}
inline void Command_P2POperation_Operation::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Command_P2POperation_Operation::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Command_P2POperation_Operation::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_P2POperation_Operation::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Command_P2POperation_Operation::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_P2POperation_Operation::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes version = 4;
inline bool Command_P2POperation_Operation::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_P2POperation_Operation::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_P2POperation_Operation::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_P2POperation_Operation::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Command_P2POperation_Operation::version() const {
  return *version_;
}
inline void Command_P2POperation_Operation::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Command_P2POperation_Operation::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Command_P2POperation_Operation::set_version(const void* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_P2POperation_Operation::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* Command_P2POperation_Operation::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_P2POperation_Operation::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes newKey = 5;
inline bool Command_P2POperation_Operation::has_newkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_P2POperation_Operation::set_has_newkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_P2POperation_Operation::clear_has_newkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_P2POperation_Operation::clear_newkey() {
  if (newkey_ != &::google::protobuf::internal::kEmptyString) {
    newkey_->clear();
  }
  clear_has_newkey();
}
inline const ::std::string& Command_P2POperation_Operation::newkey() const {
  return *newkey_;
}
inline void Command_P2POperation_Operation::set_newkey(const ::std::string& value) {
  set_has_newkey();
  if (newkey_ == &::google::protobuf::internal::kEmptyString) {
    newkey_ = new ::std::string;
  }
  newkey_->assign(value);
}
inline void Command_P2POperation_Operation::set_newkey(const char* value) {
  set_has_newkey();
  if (newkey_ == &::google::protobuf::internal::kEmptyString) {
    newkey_ = new ::std::string;
  }
  newkey_->assign(value);
}
inline void Command_P2POperation_Operation::set_newkey(const void* value, size_t size) {
  set_has_newkey();
  if (newkey_ == &::google::protobuf::internal::kEmptyString) {
    newkey_ = new ::std::string;
  }
  newkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_P2POperation_Operation::mutable_newkey() {
  set_has_newkey();
  if (newkey_ == &::google::protobuf::internal::kEmptyString) {
    newkey_ = new ::std::string;
  }
  return newkey_;
}
inline ::std::string* Command_P2POperation_Operation::release_newkey() {
  clear_has_newkey();
  if (newkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newkey_;
    newkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_P2POperation_Operation::set_allocated_newkey(::std::string* newkey) {
  if (newkey_ != &::google::protobuf::internal::kEmptyString) {
    delete newkey_;
  }
  if (newkey) {
    set_has_newkey();
    newkey_ = newkey;
  } else {
    clear_has_newkey();
    newkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool force = 6;
inline bool Command_P2POperation_Operation::has_force() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_P2POperation_Operation::set_has_force() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_P2POperation_Operation::clear_has_force() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_P2POperation_Operation::clear_force() {
  force_ = false;
  clear_has_force();
}
inline bool Command_P2POperation_Operation::force() const {
  return force_;
}
inline void Command_P2POperation_Operation::set_force(bool value) {
  set_has_force();
  force_ = value;
}

// optional .com.seagate.kinetic.client.proto.Command.Status status = 7;
inline bool Command_P2POperation_Operation::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_P2POperation_Operation::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_P2POperation_Operation::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_P2POperation_Operation::clear_status() {
  if (status_ != NULL) status_->::com::seagate::kinetic::client::proto::Command_Status::Clear();
  clear_has_status();
}
inline const ::com::seagate::kinetic::client::proto::Command_Status& Command_P2POperation_Operation::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::com::seagate::kinetic::client::proto::Command_Status* Command_P2POperation_Operation::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::seagate::kinetic::client::proto::Command_Status;
  return status_;
}
inline ::com::seagate::kinetic::client::proto::Command_Status* Command_P2POperation_Operation::release_status() {
  clear_has_status();
  ::com::seagate::kinetic::client::proto::Command_Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Command_P2POperation_Operation::set_allocated_status(::com::seagate::kinetic::client::proto::Command_Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.P2POperation p2pop = 8;
inline bool Command_P2POperation_Operation::has_p2pop() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_P2POperation_Operation::set_has_p2pop() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_P2POperation_Operation::clear_has_p2pop() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_P2POperation_Operation::clear_p2pop() {
  if (p2pop_ != NULL) p2pop_->::com::seagate::kinetic::client::proto::Command_P2POperation::Clear();
  clear_has_p2pop();
}
inline const ::com::seagate::kinetic::client::proto::Command_P2POperation& Command_P2POperation_Operation::p2pop() const {
  return p2pop_ != NULL ? *p2pop_ : *default_instance_->p2pop_;
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation* Command_P2POperation_Operation::mutable_p2pop() {
  set_has_p2pop();
  if (p2pop_ == NULL) p2pop_ = new ::com::seagate::kinetic::client::proto::Command_P2POperation;
  return p2pop_;
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation* Command_P2POperation_Operation::release_p2pop() {
  clear_has_p2pop();
  ::com::seagate::kinetic::client::proto::Command_P2POperation* temp = p2pop_;
  p2pop_ = NULL;
  return temp;
}
inline void Command_P2POperation_Operation::set_allocated_p2pop(::com::seagate::kinetic::client::proto::Command_P2POperation* p2pop) {
  delete p2pop_;
  p2pop_ = p2pop;
  if (p2pop) {
    set_has_p2pop();
  } else {
    clear_has_p2pop();
  }
}

// -------------------------------------------------------------------

// Command_P2POperation_Peer

// optional string hostname = 1;
inline bool Command_P2POperation_Peer::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_P2POperation_Peer::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_P2POperation_Peer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_P2POperation_Peer::clear_hostname() {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    hostname_->clear();
  }
  clear_has_hostname();
}
inline const ::std::string& Command_P2POperation_Peer::hostname() const {
  return *hostname_;
}
inline void Command_P2POperation_Peer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Command_P2POperation_Peer::set_hostname(const char* value) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(value);
}
inline void Command_P2POperation_Peer::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_P2POperation_Peer::mutable_hostname() {
  set_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    hostname_ = new ::std::string;
  }
  return hostname_;
}
inline ::std::string* Command_P2POperation_Peer::release_hostname() {
  clear_has_hostname();
  if (hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hostname_;
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_P2POperation_Peer::set_allocated_hostname(::std::string* hostname) {
  if (hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete hostname_;
  }
  if (hostname) {
    set_has_hostname();
    hostname_ = hostname;
  } else {
    clear_has_hostname();
    hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 port = 2;
inline bool Command_P2POperation_Peer::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_P2POperation_Peer::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_P2POperation_Peer::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_P2POperation_Peer::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Command_P2POperation_Peer::port() const {
  return port_;
}
inline void Command_P2POperation_Peer::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional bool tls = 3;
inline bool Command_P2POperation_Peer::has_tls() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_P2POperation_Peer::set_has_tls() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_P2POperation_Peer::clear_has_tls() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_P2POperation_Peer::clear_tls() {
  tls_ = false;
  clear_has_tls();
}
inline bool Command_P2POperation_Peer::tls() const {
  return tls_;
}
inline void Command_P2POperation_Peer::set_tls(bool value) {
  set_has_tls();
  tls_ = value;
}

// -------------------------------------------------------------------

// Command_P2POperation

// optional .com.seagate.kinetic.client.proto.Command.P2POperation.Peer peer = 1;
inline bool Command_P2POperation::has_peer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_P2POperation::set_has_peer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_P2POperation::clear_has_peer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_P2POperation::clear_peer() {
  if (peer_ != NULL) peer_->::com::seagate::kinetic::client::proto::Command_P2POperation_Peer::Clear();
  clear_has_peer();
}
inline const ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer& Command_P2POperation::peer() const {
  return peer_ != NULL ? *peer_ : *default_instance_->peer_;
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* Command_P2POperation::mutable_peer() {
  set_has_peer();
  if (peer_ == NULL) peer_ = new ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer;
  return peer_;
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* Command_P2POperation::release_peer() {
  clear_has_peer();
  ::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* temp = peer_;
  peer_ = NULL;
  return temp;
}
inline void Command_P2POperation::set_allocated_peer(::com::seagate::kinetic::client::proto::Command_P2POperation_Peer* peer) {
  delete peer_;
  peer_ = peer;
  if (peer) {
    set_has_peer();
  } else {
    clear_has_peer();
  }
}

// repeated .com.seagate.kinetic.client.proto.Command.P2POperation.Operation operation = 2;
inline int Command_P2POperation::operation_size() const {
  return operation_.size();
}
inline void Command_P2POperation::clear_operation() {
  operation_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation& Command_P2POperation::operation(int index) const {
  return operation_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation* Command_P2POperation::mutable_operation(int index) {
  return operation_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation* Command_P2POperation::add_operation() {
  return operation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation >&
Command_P2POperation::operation() const {
  return operation_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_P2POperation_Operation >*
Command_P2POperation::mutable_operation() {
  return &operation_;
}

// optional bool allChildOperationsSucceeded = 3;
inline bool Command_P2POperation::has_allchildoperationssucceeded() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_P2POperation::set_has_allchildoperationssucceeded() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_P2POperation::clear_has_allchildoperationssucceeded() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_P2POperation::clear_allchildoperationssucceeded() {
  allchildoperationssucceeded_ = false;
  clear_has_allchildoperationssucceeded();
}
inline bool Command_P2POperation::allchildoperationssucceeded() const {
  return allchildoperationssucceeded_;
}
inline void Command_P2POperation::set_allchildoperationssucceeded(bool value) {
  set_has_allchildoperationssucceeded();
  allchildoperationssucceeded_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Utilization

// optional string name = 1;
inline bool Command_GetLog_Utilization::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Utilization::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Utilization::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Utilization::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Command_GetLog_Utilization::name() const {
  return *name_;
}
inline void Command_GetLog_Utilization::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Utilization::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Utilization::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Utilization::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Command_GetLog_Utilization::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Utilization::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float value = 2;
inline bool Command_GetLog_Utilization::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Utilization::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Utilization::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Utilization::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float Command_GetLog_Utilization::value() const {
  return value_;
}
inline void Command_GetLog_Utilization::set_value(float value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Temperature

// optional string name = 1;
inline bool Command_GetLog_Temperature::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Temperature::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Temperature::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Temperature::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Command_GetLog_Temperature::name() const {
  return *name_;
}
inline void Command_GetLog_Temperature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Temperature::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Temperature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Temperature::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Command_GetLog_Temperature::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Temperature::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float current = 2;
inline bool Command_GetLog_Temperature::has_current() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Temperature::set_has_current() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Temperature::clear_has_current() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Temperature::clear_current() {
  current_ = 0;
  clear_has_current();
}
inline float Command_GetLog_Temperature::current() const {
  return current_;
}
inline void Command_GetLog_Temperature::set_current(float value) {
  set_has_current();
  current_ = value;
}

// optional float minimum = 3;
inline bool Command_GetLog_Temperature::has_minimum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_GetLog_Temperature::set_has_minimum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_GetLog_Temperature::clear_has_minimum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_GetLog_Temperature::clear_minimum() {
  minimum_ = 0;
  clear_has_minimum();
}
inline float Command_GetLog_Temperature::minimum() const {
  return minimum_;
}
inline void Command_GetLog_Temperature::set_minimum(float value) {
  set_has_minimum();
  minimum_ = value;
}

// optional float maximum = 4;
inline bool Command_GetLog_Temperature::has_maximum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_GetLog_Temperature::set_has_maximum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_GetLog_Temperature::clear_has_maximum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_GetLog_Temperature::clear_maximum() {
  maximum_ = 0;
  clear_has_maximum();
}
inline float Command_GetLog_Temperature::maximum() const {
  return maximum_;
}
inline void Command_GetLog_Temperature::set_maximum(float value) {
  set_has_maximum();
  maximum_ = value;
}

// optional float target = 5;
inline bool Command_GetLog_Temperature::has_target() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_GetLog_Temperature::set_has_target() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_GetLog_Temperature::clear_has_target() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_GetLog_Temperature::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline float Command_GetLog_Temperature::target() const {
  return target_;
}
inline void Command_GetLog_Temperature::set_target(float value) {
  set_has_target();
  target_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Capacity

// optional uint64 nominalCapacityInBytes = 4;
inline bool Command_GetLog_Capacity::has_nominalcapacityinbytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Capacity::set_has_nominalcapacityinbytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Capacity::clear_has_nominalcapacityinbytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Capacity::clear_nominalcapacityinbytes() {
  nominalcapacityinbytes_ = GOOGLE_ULONGLONG(0);
  clear_has_nominalcapacityinbytes();
}
inline ::google::protobuf::uint64 Command_GetLog_Capacity::nominalcapacityinbytes() const {
  return nominalcapacityinbytes_;
}
inline void Command_GetLog_Capacity::set_nominalcapacityinbytes(::google::protobuf::uint64 value) {
  set_has_nominalcapacityinbytes();
  nominalcapacityinbytes_ = value;
}

// optional float portionFull = 5;
inline bool Command_GetLog_Capacity::has_portionfull() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Capacity::set_has_portionfull() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Capacity::clear_has_portionfull() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Capacity::clear_portionfull() {
  portionfull_ = 0;
  clear_has_portionfull();
}
inline float Command_GetLog_Capacity::portionfull() const {
  return portionfull_;
}
inline void Command_GetLog_Capacity::set_portionfull(float value) {
  set_has_portionfull();
  portionfull_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Configuration_Interface

// optional string name = 1;
inline bool Command_GetLog_Configuration_Interface::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Configuration_Interface::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Configuration_Interface::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Configuration_Interface::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Command_GetLog_Configuration_Interface::name() const {
  return *name_;
}
inline void Command_GetLog_Configuration_Interface::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration_Interface::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Command_GetLog_Configuration_Interface::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration_Interface::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes MAC = 2;
inline bool Command_GetLog_Configuration_Interface::has_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Configuration_Interface::set_has_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Configuration_Interface::clear_has_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Configuration_Interface::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& Command_GetLog_Configuration_Interface::mac() const {
  return *mac_;
}
inline void Command_GetLog_Configuration_Interface::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_mac(const void* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration_Interface::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* Command_GetLog_Configuration_Interface::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration_Interface::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ipv4Address = 3;
inline bool Command_GetLog_Configuration_Interface::has_ipv4address() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_GetLog_Configuration_Interface::set_has_ipv4address() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_GetLog_Configuration_Interface::clear_has_ipv4address() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_GetLog_Configuration_Interface::clear_ipv4address() {
  if (ipv4address_ != &::google::protobuf::internal::kEmptyString) {
    ipv4address_->clear();
  }
  clear_has_ipv4address();
}
inline const ::std::string& Command_GetLog_Configuration_Interface::ipv4address() const {
  return *ipv4address_;
}
inline void Command_GetLog_Configuration_Interface::set_ipv4address(const ::std::string& value) {
  set_has_ipv4address();
  if (ipv4address_ == &::google::protobuf::internal::kEmptyString) {
    ipv4address_ = new ::std::string;
  }
  ipv4address_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_ipv4address(const char* value) {
  set_has_ipv4address();
  if (ipv4address_ == &::google::protobuf::internal::kEmptyString) {
    ipv4address_ = new ::std::string;
  }
  ipv4address_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_ipv4address(const void* value, size_t size) {
  set_has_ipv4address();
  if (ipv4address_ == &::google::protobuf::internal::kEmptyString) {
    ipv4address_ = new ::std::string;
  }
  ipv4address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration_Interface::mutable_ipv4address() {
  set_has_ipv4address();
  if (ipv4address_ == &::google::protobuf::internal::kEmptyString) {
    ipv4address_ = new ::std::string;
  }
  return ipv4address_;
}
inline ::std::string* Command_GetLog_Configuration_Interface::release_ipv4address() {
  clear_has_ipv4address();
  if (ipv4address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipv4address_;
    ipv4address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration_Interface::set_allocated_ipv4address(::std::string* ipv4address) {
  if (ipv4address_ != &::google::protobuf::internal::kEmptyString) {
    delete ipv4address_;
  }
  if (ipv4address) {
    set_has_ipv4address();
    ipv4address_ = ipv4address;
  } else {
    clear_has_ipv4address();
    ipv4address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes ipv6Address = 4;
inline bool Command_GetLog_Configuration_Interface::has_ipv6address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_GetLog_Configuration_Interface::set_has_ipv6address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_GetLog_Configuration_Interface::clear_has_ipv6address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_GetLog_Configuration_Interface::clear_ipv6address() {
  if (ipv6address_ != &::google::protobuf::internal::kEmptyString) {
    ipv6address_->clear();
  }
  clear_has_ipv6address();
}
inline const ::std::string& Command_GetLog_Configuration_Interface::ipv6address() const {
  return *ipv6address_;
}
inline void Command_GetLog_Configuration_Interface::set_ipv6address(const ::std::string& value) {
  set_has_ipv6address();
  if (ipv6address_ == &::google::protobuf::internal::kEmptyString) {
    ipv6address_ = new ::std::string;
  }
  ipv6address_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_ipv6address(const char* value) {
  set_has_ipv6address();
  if (ipv6address_ == &::google::protobuf::internal::kEmptyString) {
    ipv6address_ = new ::std::string;
  }
  ipv6address_->assign(value);
}
inline void Command_GetLog_Configuration_Interface::set_ipv6address(const void* value, size_t size) {
  set_has_ipv6address();
  if (ipv6address_ == &::google::protobuf::internal::kEmptyString) {
    ipv6address_ = new ::std::string;
  }
  ipv6address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration_Interface::mutable_ipv6address() {
  set_has_ipv6address();
  if (ipv6address_ == &::google::protobuf::internal::kEmptyString) {
    ipv6address_ = new ::std::string;
  }
  return ipv6address_;
}
inline ::std::string* Command_GetLog_Configuration_Interface::release_ipv6address() {
  clear_has_ipv6address();
  if (ipv6address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipv6address_;
    ipv6address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration_Interface::set_allocated_ipv6address(::std::string* ipv6address) {
  if (ipv6address_ != &::google::protobuf::internal::kEmptyString) {
    delete ipv6address_;
  }
  if (ipv6address) {
    set_has_ipv6address();
    ipv6address_ = ipv6address;
  } else {
    clear_has_ipv6address();
    ipv6address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command_GetLog_Configuration

// optional string vendor = 5;
inline bool Command_GetLog_Configuration::has_vendor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Configuration::set_has_vendor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Configuration::clear_has_vendor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Configuration::clear_vendor() {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    vendor_->clear();
  }
  clear_has_vendor();
}
inline const ::std::string& Command_GetLog_Configuration::vendor() const {
  return *vendor_;
}
inline void Command_GetLog_Configuration::set_vendor(const ::std::string& value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Command_GetLog_Configuration::set_vendor(const char* value) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(value);
}
inline void Command_GetLog_Configuration::set_vendor(const char* value, size_t size) {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  vendor_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_vendor() {
  set_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    vendor_ = new ::std::string;
  }
  return vendor_;
}
inline ::std::string* Command_GetLog_Configuration::release_vendor() {
  clear_has_vendor();
  if (vendor_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = vendor_;
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_vendor(::std::string* vendor) {
  if (vendor_ != &::google::protobuf::internal::kEmptyString) {
    delete vendor_;
  }
  if (vendor) {
    set_has_vendor();
    vendor_ = vendor;
  } else {
    clear_has_vendor();
    vendor_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string model = 6;
inline bool Command_GetLog_Configuration::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Configuration::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Configuration::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Configuration::clear_model() {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    model_->clear();
  }
  clear_has_model();
}
inline const ::std::string& Command_GetLog_Configuration::model() const {
  return *model_;
}
inline void Command_GetLog_Configuration::set_model(const ::std::string& value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void Command_GetLog_Configuration::set_model(const char* value) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(value);
}
inline void Command_GetLog_Configuration::set_model(const char* value, size_t size) {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  model_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_model() {
  set_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    model_ = new ::std::string;
  }
  return model_;
}
inline ::std::string* Command_GetLog_Configuration::release_model() {
  clear_has_model();
  if (model_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_;
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_model(::std::string* model) {
  if (model_ != &::google::protobuf::internal::kEmptyString) {
    delete model_;
  }
  if (model) {
    set_has_model();
    model_ = model;
  } else {
    clear_has_model();
    model_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes serialNumber = 7;
inline bool Command_GetLog_Configuration::has_serialnumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_GetLog_Configuration::set_has_serialnumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_GetLog_Configuration::clear_has_serialnumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_GetLog_Configuration::clear_serialnumber() {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    serialnumber_->clear();
  }
  clear_has_serialnumber();
}
inline const ::std::string& Command_GetLog_Configuration::serialnumber() const {
  return *serialnumber_;
}
inline void Command_GetLog_Configuration::set_serialnumber(const ::std::string& value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void Command_GetLog_Configuration::set_serialnumber(const char* value) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(value);
}
inline void Command_GetLog_Configuration::set_serialnumber(const void* value, size_t size) {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  serialnumber_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_serialnumber() {
  set_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    serialnumber_ = new ::std::string;
  }
  return serialnumber_;
}
inline ::std::string* Command_GetLog_Configuration::release_serialnumber() {
  clear_has_serialnumber();
  if (serialnumber_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serialnumber_;
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_serialnumber(::std::string* serialnumber) {
  if (serialnumber_ != &::google::protobuf::internal::kEmptyString) {
    delete serialnumber_;
  }
  if (serialnumber) {
    set_has_serialnumber();
    serialnumber_ = serialnumber;
  } else {
    clear_has_serialnumber();
    serialnumber_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes worldWideName = 14;
inline bool Command_GetLog_Configuration::has_worldwidename() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_GetLog_Configuration::set_has_worldwidename() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_GetLog_Configuration::clear_has_worldwidename() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_GetLog_Configuration::clear_worldwidename() {
  if (worldwidename_ != &::google::protobuf::internal::kEmptyString) {
    worldwidename_->clear();
  }
  clear_has_worldwidename();
}
inline const ::std::string& Command_GetLog_Configuration::worldwidename() const {
  return *worldwidename_;
}
inline void Command_GetLog_Configuration::set_worldwidename(const ::std::string& value) {
  set_has_worldwidename();
  if (worldwidename_ == &::google::protobuf::internal::kEmptyString) {
    worldwidename_ = new ::std::string;
  }
  worldwidename_->assign(value);
}
inline void Command_GetLog_Configuration::set_worldwidename(const char* value) {
  set_has_worldwidename();
  if (worldwidename_ == &::google::protobuf::internal::kEmptyString) {
    worldwidename_ = new ::std::string;
  }
  worldwidename_->assign(value);
}
inline void Command_GetLog_Configuration::set_worldwidename(const void* value, size_t size) {
  set_has_worldwidename();
  if (worldwidename_ == &::google::protobuf::internal::kEmptyString) {
    worldwidename_ = new ::std::string;
  }
  worldwidename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_worldwidename() {
  set_has_worldwidename();
  if (worldwidename_ == &::google::protobuf::internal::kEmptyString) {
    worldwidename_ = new ::std::string;
  }
  return worldwidename_;
}
inline ::std::string* Command_GetLog_Configuration::release_worldwidename() {
  clear_has_worldwidename();
  if (worldwidename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = worldwidename_;
    worldwidename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_worldwidename(::std::string* worldwidename) {
  if (worldwidename_ != &::google::protobuf::internal::kEmptyString) {
    delete worldwidename_;
  }
  if (worldwidename) {
    set_has_worldwidename();
    worldwidename_ = worldwidename;
  } else {
    clear_has_worldwidename();
    worldwidename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 8;
inline bool Command_GetLog_Configuration::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_GetLog_Configuration::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_GetLog_Configuration::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_GetLog_Configuration::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& Command_GetLog_Configuration::version() const {
  return *version_;
}
inline void Command_GetLog_Configuration::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Command_GetLog_Configuration::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void Command_GetLog_Configuration::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* Command_GetLog_Configuration::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string compilationDate = 12;
inline bool Command_GetLog_Configuration::has_compilationdate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_GetLog_Configuration::set_has_compilationdate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_GetLog_Configuration::clear_has_compilationdate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_GetLog_Configuration::clear_compilationdate() {
  if (compilationdate_ != &::google::protobuf::internal::kEmptyString) {
    compilationdate_->clear();
  }
  clear_has_compilationdate();
}
inline const ::std::string& Command_GetLog_Configuration::compilationdate() const {
  return *compilationdate_;
}
inline void Command_GetLog_Configuration::set_compilationdate(const ::std::string& value) {
  set_has_compilationdate();
  if (compilationdate_ == &::google::protobuf::internal::kEmptyString) {
    compilationdate_ = new ::std::string;
  }
  compilationdate_->assign(value);
}
inline void Command_GetLog_Configuration::set_compilationdate(const char* value) {
  set_has_compilationdate();
  if (compilationdate_ == &::google::protobuf::internal::kEmptyString) {
    compilationdate_ = new ::std::string;
  }
  compilationdate_->assign(value);
}
inline void Command_GetLog_Configuration::set_compilationdate(const char* value, size_t size) {
  set_has_compilationdate();
  if (compilationdate_ == &::google::protobuf::internal::kEmptyString) {
    compilationdate_ = new ::std::string;
  }
  compilationdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_compilationdate() {
  set_has_compilationdate();
  if (compilationdate_ == &::google::protobuf::internal::kEmptyString) {
    compilationdate_ = new ::std::string;
  }
  return compilationdate_;
}
inline ::std::string* Command_GetLog_Configuration::release_compilationdate() {
  clear_has_compilationdate();
  if (compilationdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compilationdate_;
    compilationdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_compilationdate(::std::string* compilationdate) {
  if (compilationdate_ != &::google::protobuf::internal::kEmptyString) {
    delete compilationdate_;
  }
  if (compilationdate) {
    set_has_compilationdate();
    compilationdate_ = compilationdate;
  } else {
    clear_has_compilationdate();
    compilationdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sourceHash = 13;
inline bool Command_GetLog_Configuration::has_sourcehash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command_GetLog_Configuration::set_has_sourcehash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command_GetLog_Configuration::clear_has_sourcehash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command_GetLog_Configuration::clear_sourcehash() {
  if (sourcehash_ != &::google::protobuf::internal::kEmptyString) {
    sourcehash_->clear();
  }
  clear_has_sourcehash();
}
inline const ::std::string& Command_GetLog_Configuration::sourcehash() const {
  return *sourcehash_;
}
inline void Command_GetLog_Configuration::set_sourcehash(const ::std::string& value) {
  set_has_sourcehash();
  if (sourcehash_ == &::google::protobuf::internal::kEmptyString) {
    sourcehash_ = new ::std::string;
  }
  sourcehash_->assign(value);
}
inline void Command_GetLog_Configuration::set_sourcehash(const char* value) {
  set_has_sourcehash();
  if (sourcehash_ == &::google::protobuf::internal::kEmptyString) {
    sourcehash_ = new ::std::string;
  }
  sourcehash_->assign(value);
}
inline void Command_GetLog_Configuration::set_sourcehash(const char* value, size_t size) {
  set_has_sourcehash();
  if (sourcehash_ == &::google::protobuf::internal::kEmptyString) {
    sourcehash_ = new ::std::string;
  }
  sourcehash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_sourcehash() {
  set_has_sourcehash();
  if (sourcehash_ == &::google::protobuf::internal::kEmptyString) {
    sourcehash_ = new ::std::string;
  }
  return sourcehash_;
}
inline ::std::string* Command_GetLog_Configuration::release_sourcehash() {
  clear_has_sourcehash();
  if (sourcehash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sourcehash_;
    sourcehash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_sourcehash(::std::string* sourcehash) {
  if (sourcehash_ != &::google::protobuf::internal::kEmptyString) {
    delete sourcehash_;
  }
  if (sourcehash) {
    set_has_sourcehash();
    sourcehash_ = sourcehash;
  } else {
    clear_has_sourcehash();
    sourcehash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string protocolVersion = 15;
inline bool Command_GetLog_Configuration::has_protocolversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command_GetLog_Configuration::set_has_protocolversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command_GetLog_Configuration::clear_has_protocolversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command_GetLog_Configuration::clear_protocolversion() {
  if (protocolversion_ != &::google::protobuf::internal::kEmptyString) {
    protocolversion_->clear();
  }
  clear_has_protocolversion();
}
inline const ::std::string& Command_GetLog_Configuration::protocolversion() const {
  return *protocolversion_;
}
inline void Command_GetLog_Configuration::set_protocolversion(const ::std::string& value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void Command_GetLog_Configuration::set_protocolversion(const char* value) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(value);
}
inline void Command_GetLog_Configuration::set_protocolversion(const char* value, size_t size) {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  protocolversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_protocolversion() {
  set_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    protocolversion_ = new ::std::string;
  }
  return protocolversion_;
}
inline ::std::string* Command_GetLog_Configuration::release_protocolversion() {
  clear_has_protocolversion();
  if (protocolversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocolversion_;
    protocolversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_protocolversion(::std::string* protocolversion) {
  if (protocolversion_ != &::google::protobuf::internal::kEmptyString) {
    delete protocolversion_;
  }
  if (protocolversion) {
    set_has_protocolversion();
    protocolversion_ = protocolversion;
  } else {
    clear_has_protocolversion();
    protocolversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string protocolCompilationDate = 16;
inline bool Command_GetLog_Configuration::has_protocolcompilationdate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command_GetLog_Configuration::set_has_protocolcompilationdate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command_GetLog_Configuration::clear_has_protocolcompilationdate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command_GetLog_Configuration::clear_protocolcompilationdate() {
  if (protocolcompilationdate_ != &::google::protobuf::internal::kEmptyString) {
    protocolcompilationdate_->clear();
  }
  clear_has_protocolcompilationdate();
}
inline const ::std::string& Command_GetLog_Configuration::protocolcompilationdate() const {
  return *protocolcompilationdate_;
}
inline void Command_GetLog_Configuration::set_protocolcompilationdate(const ::std::string& value) {
  set_has_protocolcompilationdate();
  if (protocolcompilationdate_ == &::google::protobuf::internal::kEmptyString) {
    protocolcompilationdate_ = new ::std::string;
  }
  protocolcompilationdate_->assign(value);
}
inline void Command_GetLog_Configuration::set_protocolcompilationdate(const char* value) {
  set_has_protocolcompilationdate();
  if (protocolcompilationdate_ == &::google::protobuf::internal::kEmptyString) {
    protocolcompilationdate_ = new ::std::string;
  }
  protocolcompilationdate_->assign(value);
}
inline void Command_GetLog_Configuration::set_protocolcompilationdate(const char* value, size_t size) {
  set_has_protocolcompilationdate();
  if (protocolcompilationdate_ == &::google::protobuf::internal::kEmptyString) {
    protocolcompilationdate_ = new ::std::string;
  }
  protocolcompilationdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_protocolcompilationdate() {
  set_has_protocolcompilationdate();
  if (protocolcompilationdate_ == &::google::protobuf::internal::kEmptyString) {
    protocolcompilationdate_ = new ::std::string;
  }
  return protocolcompilationdate_;
}
inline ::std::string* Command_GetLog_Configuration::release_protocolcompilationdate() {
  clear_has_protocolcompilationdate();
  if (protocolcompilationdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocolcompilationdate_;
    protocolcompilationdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_protocolcompilationdate(::std::string* protocolcompilationdate) {
  if (protocolcompilationdate_ != &::google::protobuf::internal::kEmptyString) {
    delete protocolcompilationdate_;
  }
  if (protocolcompilationdate) {
    set_has_protocolcompilationdate();
    protocolcompilationdate_ = protocolcompilationdate;
  } else {
    clear_has_protocolcompilationdate();
    protocolcompilationdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string protocolSourceHash = 17;
inline bool Command_GetLog_Configuration::has_protocolsourcehash() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command_GetLog_Configuration::set_has_protocolsourcehash() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command_GetLog_Configuration::clear_has_protocolsourcehash() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command_GetLog_Configuration::clear_protocolsourcehash() {
  if (protocolsourcehash_ != &::google::protobuf::internal::kEmptyString) {
    protocolsourcehash_->clear();
  }
  clear_has_protocolsourcehash();
}
inline const ::std::string& Command_GetLog_Configuration::protocolsourcehash() const {
  return *protocolsourcehash_;
}
inline void Command_GetLog_Configuration::set_protocolsourcehash(const ::std::string& value) {
  set_has_protocolsourcehash();
  if (protocolsourcehash_ == &::google::protobuf::internal::kEmptyString) {
    protocolsourcehash_ = new ::std::string;
  }
  protocolsourcehash_->assign(value);
}
inline void Command_GetLog_Configuration::set_protocolsourcehash(const char* value) {
  set_has_protocolsourcehash();
  if (protocolsourcehash_ == &::google::protobuf::internal::kEmptyString) {
    protocolsourcehash_ = new ::std::string;
  }
  protocolsourcehash_->assign(value);
}
inline void Command_GetLog_Configuration::set_protocolsourcehash(const char* value, size_t size) {
  set_has_protocolsourcehash();
  if (protocolsourcehash_ == &::google::protobuf::internal::kEmptyString) {
    protocolsourcehash_ = new ::std::string;
  }
  protocolsourcehash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Configuration::mutable_protocolsourcehash() {
  set_has_protocolsourcehash();
  if (protocolsourcehash_ == &::google::protobuf::internal::kEmptyString) {
    protocolsourcehash_ = new ::std::string;
  }
  return protocolsourcehash_;
}
inline ::std::string* Command_GetLog_Configuration::release_protocolsourcehash() {
  clear_has_protocolsourcehash();
  if (protocolsourcehash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = protocolsourcehash_;
    protocolsourcehash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Configuration::set_allocated_protocolsourcehash(::std::string* protocolsourcehash) {
  if (protocolsourcehash_ != &::google::protobuf::internal::kEmptyString) {
    delete protocolsourcehash_;
  }
  if (protocolsourcehash) {
    set_has_protocolsourcehash();
    protocolsourcehash_ = protocolsourcehash;
  } else {
    clear_has_protocolsourcehash();
    protocolsourcehash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.seagate.kinetic.client.proto.Command.GetLog.Configuration.Interface interface = 9;
inline int Command_GetLog_Configuration::interface_size() const {
  return interface_.size();
}
inline void Command_GetLog_Configuration::clear_interface() {
  interface_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface& Command_GetLog_Configuration::interface(int index) const {
  return interface_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface* Command_GetLog_Configuration::mutable_interface(int index) {
  return interface_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface* Command_GetLog_Configuration::add_interface() {
  return interface_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface >&
Command_GetLog_Configuration::interface() const {
  return interface_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration_Interface >*
Command_GetLog_Configuration::mutable_interface() {
  return &interface_;
}

// optional int32 port = 10;
inline bool Command_GetLog_Configuration::has_port() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Command_GetLog_Configuration::set_has_port() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Command_GetLog_Configuration::clear_has_port() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Command_GetLog_Configuration::clear_port() {
  port_ = 0;
  clear_has_port();
}
inline ::google::protobuf::int32 Command_GetLog_Configuration::port() const {
  return port_;
}
inline void Command_GetLog_Configuration::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
}

// optional int32 tlsPort = 11;
inline bool Command_GetLog_Configuration::has_tlsport() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Command_GetLog_Configuration::set_has_tlsport() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Command_GetLog_Configuration::clear_has_tlsport() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Command_GetLog_Configuration::clear_tlsport() {
  tlsport_ = 0;
  clear_has_tlsport();
}
inline ::google::protobuf::int32 Command_GetLog_Configuration::tlsport() const {
  return tlsport_;
}
inline void Command_GetLog_Configuration::set_tlsport(::google::protobuf::int32 value) {
  set_has_tlsport();
  tlsport_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Statistics

// optional .com.seagate.kinetic.client.proto.Command.MessageType messageType = 1;
inline bool Command_GetLog_Statistics::has_messagetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Statistics::set_has_messagetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Statistics::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Statistics::clear_messagetype() {
  messagetype_ = -1;
  clear_has_messagetype();
}
inline ::com::seagate::kinetic::client::proto::Command_MessageType Command_GetLog_Statistics::messagetype() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_MessageType >(messagetype_);
}
inline void Command_GetLog_Statistics::set_messagetype(::com::seagate::kinetic::client::proto::Command_MessageType value) {
  assert(::com::seagate::kinetic::client::proto::Command_MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
}

// optional uint64 count = 4;
inline bool Command_GetLog_Statistics::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Statistics::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Statistics::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Statistics::clear_count() {
  count_ = GOOGLE_ULONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::uint64 Command_GetLog_Statistics::count() const {
  return count_;
}
inline void Command_GetLog_Statistics::set_count(::google::protobuf::uint64 value) {
  set_has_count();
  count_ = value;
}

// optional uint64 bytes = 5;
inline bool Command_GetLog_Statistics::has_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_GetLog_Statistics::set_has_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_GetLog_Statistics::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_GetLog_Statistics::clear_bytes() {
  bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes();
}
inline ::google::protobuf::uint64 Command_GetLog_Statistics::bytes() const {
  return bytes_;
}
inline void Command_GetLog_Statistics::set_bytes(::google::protobuf::uint64 value) {
  set_has_bytes();
  bytes_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Limits

// optional uint32 maxKeySize = 1;
inline bool Command_GetLog_Limits::has_maxkeysize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxkeysize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Limits::clear_has_maxkeysize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Limits::clear_maxkeysize() {
  maxkeysize_ = 0u;
  clear_has_maxkeysize();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxkeysize() const {
  return maxkeysize_;
}
inline void Command_GetLog_Limits::set_maxkeysize(::google::protobuf::uint32 value) {
  set_has_maxkeysize();
  maxkeysize_ = value;
}

// optional uint32 maxValueSize = 2;
inline bool Command_GetLog_Limits::has_maxvaluesize() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxvaluesize() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_GetLog_Limits::clear_has_maxvaluesize() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_GetLog_Limits::clear_maxvaluesize() {
  maxvaluesize_ = 0u;
  clear_has_maxvaluesize();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxvaluesize() const {
  return maxvaluesize_;
}
inline void Command_GetLog_Limits::set_maxvaluesize(::google::protobuf::uint32 value) {
  set_has_maxvaluesize();
  maxvaluesize_ = value;
}

// optional uint32 maxVersionSize = 3;
inline bool Command_GetLog_Limits::has_maxversionsize() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxversionsize() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_GetLog_Limits::clear_has_maxversionsize() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_GetLog_Limits::clear_maxversionsize() {
  maxversionsize_ = 0u;
  clear_has_maxversionsize();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxversionsize() const {
  return maxversionsize_;
}
inline void Command_GetLog_Limits::set_maxversionsize(::google::protobuf::uint32 value) {
  set_has_maxversionsize();
  maxversionsize_ = value;
}

// optional uint32 maxTagSize = 4;
inline bool Command_GetLog_Limits::has_maxtagsize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxtagsize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_GetLog_Limits::clear_has_maxtagsize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_GetLog_Limits::clear_maxtagsize() {
  maxtagsize_ = 0u;
  clear_has_maxtagsize();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxtagsize() const {
  return maxtagsize_;
}
inline void Command_GetLog_Limits::set_maxtagsize(::google::protobuf::uint32 value) {
  set_has_maxtagsize();
  maxtagsize_ = value;
}

// optional uint32 maxConnections = 5;
inline bool Command_GetLog_Limits::has_maxconnections() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxconnections() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_GetLog_Limits::clear_has_maxconnections() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_GetLog_Limits::clear_maxconnections() {
  maxconnections_ = 0u;
  clear_has_maxconnections();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxconnections() const {
  return maxconnections_;
}
inline void Command_GetLog_Limits::set_maxconnections(::google::protobuf::uint32 value) {
  set_has_maxconnections();
  maxconnections_ = value;
}

// optional uint32 maxOutstandingReadRequests = 6;
inline bool Command_GetLog_Limits::has_maxoutstandingreadrequests() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxoutstandingreadrequests() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Command_GetLog_Limits::clear_has_maxoutstandingreadrequests() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Command_GetLog_Limits::clear_maxoutstandingreadrequests() {
  maxoutstandingreadrequests_ = 0u;
  clear_has_maxoutstandingreadrequests();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxoutstandingreadrequests() const {
  return maxoutstandingreadrequests_;
}
inline void Command_GetLog_Limits::set_maxoutstandingreadrequests(::google::protobuf::uint32 value) {
  set_has_maxoutstandingreadrequests();
  maxoutstandingreadrequests_ = value;
}

// optional uint32 maxOutstandingWriteRequests = 7;
inline bool Command_GetLog_Limits::has_maxoutstandingwriterequests() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxoutstandingwriterequests() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command_GetLog_Limits::clear_has_maxoutstandingwriterequests() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command_GetLog_Limits::clear_maxoutstandingwriterequests() {
  maxoutstandingwriterequests_ = 0u;
  clear_has_maxoutstandingwriterequests();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxoutstandingwriterequests() const {
  return maxoutstandingwriterequests_;
}
inline void Command_GetLog_Limits::set_maxoutstandingwriterequests(::google::protobuf::uint32 value) {
  set_has_maxoutstandingwriterequests();
  maxoutstandingwriterequests_ = value;
}

// optional uint32 maxMessageSize = 8;
inline bool Command_GetLog_Limits::has_maxmessagesize() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxmessagesize() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command_GetLog_Limits::clear_has_maxmessagesize() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command_GetLog_Limits::clear_maxmessagesize() {
  maxmessagesize_ = 0u;
  clear_has_maxmessagesize();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxmessagesize() const {
  return maxmessagesize_;
}
inline void Command_GetLog_Limits::set_maxmessagesize(::google::protobuf::uint32 value) {
  set_has_maxmessagesize();
  maxmessagesize_ = value;
}

// optional uint32 maxKeyRangeCount = 9;
inline bool Command_GetLog_Limits::has_maxkeyrangecount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxkeyrangecount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command_GetLog_Limits::clear_has_maxkeyrangecount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command_GetLog_Limits::clear_maxkeyrangecount() {
  maxkeyrangecount_ = 0u;
  clear_has_maxkeyrangecount();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxkeyrangecount() const {
  return maxkeyrangecount_;
}
inline void Command_GetLog_Limits::set_maxkeyrangecount(::google::protobuf::uint32 value) {
  set_has_maxkeyrangecount();
  maxkeyrangecount_ = value;
}

// optional uint32 maxIdentityCount = 10;
inline bool Command_GetLog_Limits::has_maxidentitycount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxidentitycount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Command_GetLog_Limits::clear_has_maxidentitycount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Command_GetLog_Limits::clear_maxidentitycount() {
  maxidentitycount_ = 0u;
  clear_has_maxidentitycount();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxidentitycount() const {
  return maxidentitycount_;
}
inline void Command_GetLog_Limits::set_maxidentitycount(::google::protobuf::uint32 value) {
  set_has_maxidentitycount();
  maxidentitycount_ = value;
}

// optional uint32 maxPinSize = 11;
inline bool Command_GetLog_Limits::has_maxpinsize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxpinsize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Command_GetLog_Limits::clear_has_maxpinsize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Command_GetLog_Limits::clear_maxpinsize() {
  maxpinsize_ = 0u;
  clear_has_maxpinsize();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxpinsize() const {
  return maxpinsize_;
}
inline void Command_GetLog_Limits::set_maxpinsize(::google::protobuf::uint32 value) {
  set_has_maxpinsize();
  maxpinsize_ = value;
}

// optional uint32 maxOperationCountPerBatch = 12;
inline bool Command_GetLog_Limits::has_maxoperationcountperbatch() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxoperationcountperbatch() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Command_GetLog_Limits::clear_has_maxoperationcountperbatch() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Command_GetLog_Limits::clear_maxoperationcountperbatch() {
  maxoperationcountperbatch_ = 0u;
  clear_has_maxoperationcountperbatch();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxoperationcountperbatch() const {
  return maxoperationcountperbatch_;
}
inline void Command_GetLog_Limits::set_maxoperationcountperbatch(::google::protobuf::uint32 value) {
  set_has_maxoperationcountperbatch();
  maxoperationcountperbatch_ = value;
}

// optional uint32 maxBatchCountPerDevice = 13;
inline bool Command_GetLog_Limits::has_maxbatchcountperdevice() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Command_GetLog_Limits::set_has_maxbatchcountperdevice() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Command_GetLog_Limits::clear_has_maxbatchcountperdevice() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Command_GetLog_Limits::clear_maxbatchcountperdevice() {
  maxbatchcountperdevice_ = 0u;
  clear_has_maxbatchcountperdevice();
}
inline ::google::protobuf::uint32 Command_GetLog_Limits::maxbatchcountperdevice() const {
  return maxbatchcountperdevice_;
}
inline void Command_GetLog_Limits::set_maxbatchcountperdevice(::google::protobuf::uint32 value) {
  set_has_maxbatchcountperdevice();
  maxbatchcountperdevice_ = value;
}

// -------------------------------------------------------------------

// Command_GetLog_Device

// optional bytes name = 1;
inline bool Command_GetLog_Device::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_GetLog_Device::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_GetLog_Device::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_GetLog_Device::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Command_GetLog_Device::name() const {
  return *name_;
}
inline void Command_GetLog_Device::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Device::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command_GetLog_Device::set_name(const void* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog_Device::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Command_GetLog_Device::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog_Device::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command_GetLog

// repeated .com.seagate.kinetic.client.proto.Command.GetLog.Type types = 1;
inline int Command_GetLog::types_size() const {
  return types_.size();
}
inline void Command_GetLog::clear_types() {
  types_.Clear();
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Type Command_GetLog::types(int index) const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_GetLog_Type >(types_.Get(index));
}
inline void Command_GetLog::set_types(int index, ::com::seagate::kinetic::client::proto::Command_GetLog_Type value) {
  assert(::com::seagate::kinetic::client::proto::Command_GetLog_Type_IsValid(value));
  types_.Set(index, value);
}
inline void Command_GetLog::add_types(::com::seagate::kinetic::client::proto::Command_GetLog_Type value) {
  assert(::com::seagate::kinetic::client::proto::Command_GetLog_Type_IsValid(value));
  types_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Command_GetLog::types() const {
  return types_;
}
inline ::google::protobuf::RepeatedField<int>*
Command_GetLog::mutable_types() {
  return &types_;
}

// repeated .com.seagate.kinetic.client.proto.Command.GetLog.Utilization utilizations = 2;
inline int Command_GetLog::utilizations_size() const {
  return utilizations_.size();
}
inline void Command_GetLog::clear_utilizations() {
  utilizations_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization& Command_GetLog::utilizations(int index) const {
  return utilizations_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization* Command_GetLog::mutable_utilizations(int index) {
  return utilizations_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization* Command_GetLog::add_utilizations() {
  return utilizations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization >&
Command_GetLog::utilizations() const {
  return utilizations_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Utilization >*
Command_GetLog::mutable_utilizations() {
  return &utilizations_;
}

// repeated .com.seagate.kinetic.client.proto.Command.GetLog.Temperature temperatures = 3;
inline int Command_GetLog::temperatures_size() const {
  return temperatures_.size();
}
inline void Command_GetLog::clear_temperatures() {
  temperatures_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature& Command_GetLog::temperatures(int index) const {
  return temperatures_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature* Command_GetLog::mutable_temperatures(int index) {
  return temperatures_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature* Command_GetLog::add_temperatures() {
  return temperatures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature >&
Command_GetLog::temperatures() const {
  return temperatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Temperature >*
Command_GetLog::mutable_temperatures() {
  return &temperatures_;
}

// optional .com.seagate.kinetic.client.proto.Command.GetLog.Capacity capacity = 4;
inline bool Command_GetLog::has_capacity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_GetLog::set_has_capacity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_GetLog::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_GetLog::clear_capacity() {
  if (capacity_ != NULL) capacity_->::com::seagate::kinetic::client::proto::Command_GetLog_Capacity::Clear();
  clear_has_capacity();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity& Command_GetLog::capacity() const {
  return capacity_ != NULL ? *capacity_ : *default_instance_->capacity_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* Command_GetLog::mutable_capacity() {
  set_has_capacity();
  if (capacity_ == NULL) capacity_ = new ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity;
  return capacity_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* Command_GetLog::release_capacity() {
  clear_has_capacity();
  ::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* temp = capacity_;
  capacity_ = NULL;
  return temp;
}
inline void Command_GetLog::set_allocated_capacity(::com::seagate::kinetic::client::proto::Command_GetLog_Capacity* capacity) {
  delete capacity_;
  capacity_ = capacity;
  if (capacity) {
    set_has_capacity();
  } else {
    clear_has_capacity();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.GetLog.Configuration configuration = 5;
inline bool Command_GetLog::has_configuration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_GetLog::set_has_configuration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_GetLog::clear_has_configuration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_GetLog::clear_configuration() {
  if (configuration_ != NULL) configuration_->::com::seagate::kinetic::client::proto::Command_GetLog_Configuration::Clear();
  clear_has_configuration();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration& Command_GetLog::configuration() const {
  return configuration_ != NULL ? *configuration_ : *default_instance_->configuration_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* Command_GetLog::mutable_configuration() {
  set_has_configuration();
  if (configuration_ == NULL) configuration_ = new ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration;
  return configuration_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* Command_GetLog::release_configuration() {
  clear_has_configuration();
  ::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* temp = configuration_;
  configuration_ = NULL;
  return temp;
}
inline void Command_GetLog::set_allocated_configuration(::com::seagate::kinetic::client::proto::Command_GetLog_Configuration* configuration) {
  delete configuration_;
  configuration_ = configuration;
  if (configuration) {
    set_has_configuration();
  } else {
    clear_has_configuration();
  }
}

// repeated .com.seagate.kinetic.client.proto.Command.GetLog.Statistics statistics = 6;
inline int Command_GetLog::statistics_size() const {
  return statistics_.size();
}
inline void Command_GetLog::clear_statistics() {
  statistics_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics& Command_GetLog::statistics(int index) const {
  return statistics_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics* Command_GetLog::mutable_statistics(int index) {
  return statistics_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics* Command_GetLog::add_statistics() {
  return statistics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics >&
Command_GetLog::statistics() const {
  return statistics_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_GetLog_Statistics >*
Command_GetLog::mutable_statistics() {
  return &statistics_;
}

// optional bytes messages = 7;
inline bool Command_GetLog::has_messages() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Command_GetLog::set_has_messages() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Command_GetLog::clear_has_messages() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Command_GetLog::clear_messages() {
  if (messages_ != &::google::protobuf::internal::kEmptyString) {
    messages_->clear();
  }
  clear_has_messages();
}
inline const ::std::string& Command_GetLog::messages() const {
  return *messages_;
}
inline void Command_GetLog::set_messages(const ::std::string& value) {
  set_has_messages();
  if (messages_ == &::google::protobuf::internal::kEmptyString) {
    messages_ = new ::std::string;
  }
  messages_->assign(value);
}
inline void Command_GetLog::set_messages(const char* value) {
  set_has_messages();
  if (messages_ == &::google::protobuf::internal::kEmptyString) {
    messages_ = new ::std::string;
  }
  messages_->assign(value);
}
inline void Command_GetLog::set_messages(const void* value, size_t size) {
  set_has_messages();
  if (messages_ == &::google::protobuf::internal::kEmptyString) {
    messages_ = new ::std::string;
  }
  messages_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_GetLog::mutable_messages() {
  set_has_messages();
  if (messages_ == &::google::protobuf::internal::kEmptyString) {
    messages_ = new ::std::string;
  }
  return messages_;
}
inline ::std::string* Command_GetLog::release_messages() {
  clear_has_messages();
  if (messages_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = messages_;
    messages_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_GetLog::set_allocated_messages(::std::string* messages) {
  if (messages_ != &::google::protobuf::internal::kEmptyString) {
    delete messages_;
  }
  if (messages) {
    set_has_messages();
    messages_ = messages;
  } else {
    clear_has_messages();
    messages_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.seagate.kinetic.client.proto.Command.GetLog.Limits limits = 8;
inline bool Command_GetLog::has_limits() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Command_GetLog::set_has_limits() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Command_GetLog::clear_has_limits() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Command_GetLog::clear_limits() {
  if (limits_ != NULL) limits_->::com::seagate::kinetic::client::proto::Command_GetLog_Limits::Clear();
  clear_has_limits();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Limits& Command_GetLog::limits() const {
  return limits_ != NULL ? *limits_ : *default_instance_->limits_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Limits* Command_GetLog::mutable_limits() {
  set_has_limits();
  if (limits_ == NULL) limits_ = new ::com::seagate::kinetic::client::proto::Command_GetLog_Limits;
  return limits_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Limits* Command_GetLog::release_limits() {
  clear_has_limits();
  ::com::seagate::kinetic::client::proto::Command_GetLog_Limits* temp = limits_;
  limits_ = NULL;
  return temp;
}
inline void Command_GetLog::set_allocated_limits(::com::seagate::kinetic::client::proto::Command_GetLog_Limits* limits) {
  delete limits_;
  limits_ = limits;
  if (limits) {
    set_has_limits();
  } else {
    clear_has_limits();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.GetLog.Device device = 9;
inline bool Command_GetLog::has_device() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Command_GetLog::set_has_device() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Command_GetLog::clear_has_device() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Command_GetLog::clear_device() {
  if (device_ != NULL) device_->::com::seagate::kinetic::client::proto::Command_GetLog_Device::Clear();
  clear_has_device();
}
inline const ::com::seagate::kinetic::client::proto::Command_GetLog_Device& Command_GetLog::device() const {
  return device_ != NULL ? *device_ : *default_instance_->device_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Device* Command_GetLog::mutable_device() {
  set_has_device();
  if (device_ == NULL) device_ = new ::com::seagate::kinetic::client::proto::Command_GetLog_Device;
  return device_;
}
inline ::com::seagate::kinetic::client::proto::Command_GetLog_Device* Command_GetLog::release_device() {
  clear_has_device();
  ::com::seagate::kinetic::client::proto::Command_GetLog_Device* temp = device_;
  device_ = NULL;
  return temp;
}
inline void Command_GetLog::set_allocated_device(::com::seagate::kinetic::client::proto::Command_GetLog_Device* device) {
  delete device_;
  device_ = device;
  if (device) {
    set_has_device();
  } else {
    clear_has_device();
  }
}

// -------------------------------------------------------------------

// Command_Security_ACL_Scope

// optional int64 offset = 1;
inline bool Command_Security_ACL_Scope::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Security_ACL_Scope::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Security_ACL_Scope::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Security_ACL_Scope::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::int64 Command_Security_ACL_Scope::offset() const {
  return offset_;
}
inline void Command_Security_ACL_Scope::set_offset(::google::protobuf::int64 value) {
  set_has_offset();
  offset_ = value;
}

// optional bytes value = 2;
inline bool Command_Security_ACL_Scope::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Security_ACL_Scope::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Security_ACL_Scope::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Security_ACL_Scope::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Command_Security_ACL_Scope::value() const {
  return *value_;
}
inline void Command_Security_ACL_Scope::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Command_Security_ACL_Scope::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Command_Security_ACL_Scope::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Security_ACL_Scope::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Command_Security_ACL_Scope::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Security_ACL_Scope::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.seagate.kinetic.client.proto.Command.Security.ACL.Permission permission = 3;
inline int Command_Security_ACL_Scope::permission_size() const {
  return permission_.size();
}
inline void Command_Security_ACL_Scope::clear_permission() {
  permission_.Clear();
}
inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission Command_Security_ACL_Scope::permission(int index) const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission >(permission_.Get(index));
}
inline void Command_Security_ACL_Scope::set_permission(int index, ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission value) {
  assert(::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission_IsValid(value));
  permission_.Set(index, value);
}
inline void Command_Security_ACL_Scope::add_permission(::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission value) {
  assert(::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission_IsValid(value));
  permission_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
Command_Security_ACL_Scope::permission() const {
  return permission_;
}
inline ::google::protobuf::RepeatedField<int>*
Command_Security_ACL_Scope::mutable_permission() {
  return &permission_;
}

// optional bool TlsRequired = 4;
inline bool Command_Security_ACL_Scope::has_tlsrequired() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_Security_ACL_Scope::set_has_tlsrequired() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_Security_ACL_Scope::clear_has_tlsrequired() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_Security_ACL_Scope::clear_tlsrequired() {
  tlsrequired_ = false;
  clear_has_tlsrequired();
}
inline bool Command_Security_ACL_Scope::tlsrequired() const {
  return tlsrequired_;
}
inline void Command_Security_ACL_Scope::set_tlsrequired(bool value) {
  set_has_tlsrequired();
  tlsrequired_ = value;
}

// -------------------------------------------------------------------

// Command_Security_ACL

// optional int64 identity = 1;
inline bool Command_Security_ACL::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_Security_ACL::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_Security_ACL::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_Security_ACL::clear_identity() {
  identity_ = GOOGLE_LONGLONG(0);
  clear_has_identity();
}
inline ::google::protobuf::int64 Command_Security_ACL::identity() const {
  return identity_;
}
inline void Command_Security_ACL::set_identity(::google::protobuf::int64 value) {
  set_has_identity();
  identity_ = value;
}

// optional bytes key = 2;
inline bool Command_Security_ACL::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Security_ACL::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Security_ACL::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Security_ACL::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Command_Security_ACL::key() const {
  return *key_;
}
inline void Command_Security_ACL::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Command_Security_ACL::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Command_Security_ACL::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Security_ACL::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Command_Security_ACL::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Security_ACL::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Security.ACL.HMACAlgorithm hmacAlgorithm = 3;
inline bool Command_Security_ACL::has_hmacalgorithm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Security_ACL::set_has_hmacalgorithm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Security_ACL::clear_has_hmacalgorithm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Security_ACL::clear_hmacalgorithm() {
  hmacalgorithm_ = -1;
  clear_has_hmacalgorithm();
}
inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm Command_Security_ACL::hmacalgorithm() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm >(hmacalgorithm_);
}
inline void Command_Security_ACL::set_hmacalgorithm(::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm value) {
  assert(::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm_IsValid(value));
  set_has_hmacalgorithm();
  hmacalgorithm_ = value;
}

// repeated .com.seagate.kinetic.client.proto.Command.Security.ACL.Scope scope = 4;
inline int Command_Security_ACL::scope_size() const {
  return scope_.size();
}
inline void Command_Security_ACL::clear_scope() {
  scope_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope& Command_Security_ACL::scope(int index) const {
  return scope_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope* Command_Security_ACL::mutable_scope(int index) {
  return scope_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope* Command_Security_ACL::add_scope() {
  return scope_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope >&
Command_Security_ACL::scope() const {
  return scope_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Scope >*
Command_Security_ACL::mutable_scope() {
  return &scope_;
}

// optional .com.seagate.kinetic.client.proto.Command.Priority maxPriority = 5;
inline bool Command_Security_ACL::has_maxpriority() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_Security_ACL::set_has_maxpriority() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_Security_ACL::clear_has_maxpriority() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_Security_ACL::clear_maxpriority() {
  maxpriority_ = 5;
  clear_has_maxpriority();
}
inline ::com::seagate::kinetic::client::proto::Command_Priority Command_Security_ACL::maxpriority() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_Priority >(maxpriority_);
}
inline void Command_Security_ACL::set_maxpriority(::com::seagate::kinetic::client::proto::Command_Priority value) {
  assert(::com::seagate::kinetic::client::proto::Command_Priority_IsValid(value));
  set_has_maxpriority();
  maxpriority_ = value;
}

// -------------------------------------------------------------------

// Command_Security

// repeated .com.seagate.kinetic.client.proto.Command.Security.ACL acl = 2;
inline int Command_Security::acl_size() const {
  return acl_.size();
}
inline void Command_Security::clear_acl() {
  acl_.Clear();
}
inline const ::com::seagate::kinetic::client::proto::Command_Security_ACL& Command_Security::acl(int index) const {
  return acl_.Get(index);
}
inline ::com::seagate::kinetic::client::proto::Command_Security_ACL* Command_Security::mutable_acl(int index) {
  return acl_.Mutable(index);
}
inline ::com::seagate::kinetic::client::proto::Command_Security_ACL* Command_Security::add_acl() {
  return acl_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL >&
Command_Security::acl() const {
  return acl_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::seagate::kinetic::client::proto::Command_Security_ACL >*
Command_Security::mutable_acl() {
  return &acl_;
}

// optional bytes oldLockPIN = 3;
inline bool Command_Security::has_oldlockpin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command_Security::set_has_oldlockpin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command_Security::clear_has_oldlockpin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command_Security::clear_oldlockpin() {
  if (oldlockpin_ != &::google::protobuf::internal::kEmptyString) {
    oldlockpin_->clear();
  }
  clear_has_oldlockpin();
}
inline const ::std::string& Command_Security::oldlockpin() const {
  return *oldlockpin_;
}
inline void Command_Security::set_oldlockpin(const ::std::string& value) {
  set_has_oldlockpin();
  if (oldlockpin_ == &::google::protobuf::internal::kEmptyString) {
    oldlockpin_ = new ::std::string;
  }
  oldlockpin_->assign(value);
}
inline void Command_Security::set_oldlockpin(const char* value) {
  set_has_oldlockpin();
  if (oldlockpin_ == &::google::protobuf::internal::kEmptyString) {
    oldlockpin_ = new ::std::string;
  }
  oldlockpin_->assign(value);
}
inline void Command_Security::set_oldlockpin(const void* value, size_t size) {
  set_has_oldlockpin();
  if (oldlockpin_ == &::google::protobuf::internal::kEmptyString) {
    oldlockpin_ = new ::std::string;
  }
  oldlockpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Security::mutable_oldlockpin() {
  set_has_oldlockpin();
  if (oldlockpin_ == &::google::protobuf::internal::kEmptyString) {
    oldlockpin_ = new ::std::string;
  }
  return oldlockpin_;
}
inline ::std::string* Command_Security::release_oldlockpin() {
  clear_has_oldlockpin();
  if (oldlockpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldlockpin_;
    oldlockpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Security::set_allocated_oldlockpin(::std::string* oldlockpin) {
  if (oldlockpin_ != &::google::protobuf::internal::kEmptyString) {
    delete oldlockpin_;
  }
  if (oldlockpin) {
    set_has_oldlockpin();
    oldlockpin_ = oldlockpin;
  } else {
    clear_has_oldlockpin();
    oldlockpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes newLockPIN = 4;
inline bool Command_Security::has_newlockpin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command_Security::set_has_newlockpin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command_Security::clear_has_newlockpin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command_Security::clear_newlockpin() {
  if (newlockpin_ != &::google::protobuf::internal::kEmptyString) {
    newlockpin_->clear();
  }
  clear_has_newlockpin();
}
inline const ::std::string& Command_Security::newlockpin() const {
  return *newlockpin_;
}
inline void Command_Security::set_newlockpin(const ::std::string& value) {
  set_has_newlockpin();
  if (newlockpin_ == &::google::protobuf::internal::kEmptyString) {
    newlockpin_ = new ::std::string;
  }
  newlockpin_->assign(value);
}
inline void Command_Security::set_newlockpin(const char* value) {
  set_has_newlockpin();
  if (newlockpin_ == &::google::protobuf::internal::kEmptyString) {
    newlockpin_ = new ::std::string;
  }
  newlockpin_->assign(value);
}
inline void Command_Security::set_newlockpin(const void* value, size_t size) {
  set_has_newlockpin();
  if (newlockpin_ == &::google::protobuf::internal::kEmptyString) {
    newlockpin_ = new ::std::string;
  }
  newlockpin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Security::mutable_newlockpin() {
  set_has_newlockpin();
  if (newlockpin_ == &::google::protobuf::internal::kEmptyString) {
    newlockpin_ = new ::std::string;
  }
  return newlockpin_;
}
inline ::std::string* Command_Security::release_newlockpin() {
  clear_has_newlockpin();
  if (newlockpin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newlockpin_;
    newlockpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Security::set_allocated_newlockpin(::std::string* newlockpin) {
  if (newlockpin_ != &::google::protobuf::internal::kEmptyString) {
    delete newlockpin_;
  }
  if (newlockpin) {
    set_has_newlockpin();
    newlockpin_ = newlockpin;
  } else {
    clear_has_newlockpin();
    newlockpin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes oldErasePIN = 5;
inline bool Command_Security::has_olderasepin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command_Security::set_has_olderasepin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command_Security::clear_has_olderasepin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command_Security::clear_olderasepin() {
  if (olderasepin_ != &::google::protobuf::internal::kEmptyString) {
    olderasepin_->clear();
  }
  clear_has_olderasepin();
}
inline const ::std::string& Command_Security::olderasepin() const {
  return *olderasepin_;
}
inline void Command_Security::set_olderasepin(const ::std::string& value) {
  set_has_olderasepin();
  if (olderasepin_ == &::google::protobuf::internal::kEmptyString) {
    olderasepin_ = new ::std::string;
  }
  olderasepin_->assign(value);
}
inline void Command_Security::set_olderasepin(const char* value) {
  set_has_olderasepin();
  if (olderasepin_ == &::google::protobuf::internal::kEmptyString) {
    olderasepin_ = new ::std::string;
  }
  olderasepin_->assign(value);
}
inline void Command_Security::set_olderasepin(const void* value, size_t size) {
  set_has_olderasepin();
  if (olderasepin_ == &::google::protobuf::internal::kEmptyString) {
    olderasepin_ = new ::std::string;
  }
  olderasepin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Security::mutable_olderasepin() {
  set_has_olderasepin();
  if (olderasepin_ == &::google::protobuf::internal::kEmptyString) {
    olderasepin_ = new ::std::string;
  }
  return olderasepin_;
}
inline ::std::string* Command_Security::release_olderasepin() {
  clear_has_olderasepin();
  if (olderasepin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = olderasepin_;
    olderasepin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Security::set_allocated_olderasepin(::std::string* olderasepin) {
  if (olderasepin_ != &::google::protobuf::internal::kEmptyString) {
    delete olderasepin_;
  }
  if (olderasepin) {
    set_has_olderasepin();
    olderasepin_ = olderasepin;
  } else {
    clear_has_olderasepin();
    olderasepin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes newErasePIN = 6;
inline bool Command_Security::has_newerasepin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Command_Security::set_has_newerasepin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Command_Security::clear_has_newerasepin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Command_Security::clear_newerasepin() {
  if (newerasepin_ != &::google::protobuf::internal::kEmptyString) {
    newerasepin_->clear();
  }
  clear_has_newerasepin();
}
inline const ::std::string& Command_Security::newerasepin() const {
  return *newerasepin_;
}
inline void Command_Security::set_newerasepin(const ::std::string& value) {
  set_has_newerasepin();
  if (newerasepin_ == &::google::protobuf::internal::kEmptyString) {
    newerasepin_ = new ::std::string;
  }
  newerasepin_->assign(value);
}
inline void Command_Security::set_newerasepin(const char* value) {
  set_has_newerasepin();
  if (newerasepin_ == &::google::protobuf::internal::kEmptyString) {
    newerasepin_ = new ::std::string;
  }
  newerasepin_->assign(value);
}
inline void Command_Security::set_newerasepin(const void* value, size_t size) {
  set_has_newerasepin();
  if (newerasepin_ == &::google::protobuf::internal::kEmptyString) {
    newerasepin_ = new ::std::string;
  }
  newerasepin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command_Security::mutable_newerasepin() {
  set_has_newerasepin();
  if (newerasepin_ == &::google::protobuf::internal::kEmptyString) {
    newerasepin_ = new ::std::string;
  }
  return newerasepin_;
}
inline ::std::string* Command_Security::release_newerasepin() {
  clear_has_newerasepin();
  if (newerasepin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newerasepin_;
    newerasepin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Command_Security::set_allocated_newerasepin(::std::string* newerasepin) {
  if (newerasepin_ != &::google::protobuf::internal::kEmptyString) {
    delete newerasepin_;
  }
  if (newerasepin) {
    set_has_newerasepin();
    newerasepin_ = newerasepin;
  } else {
    clear_has_newerasepin();
    newerasepin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command_PinOperation

// optional .com.seagate.kinetic.client.proto.Command.PinOperation.PinOpType pinOpType = 1;
inline bool Command_PinOperation::has_pinoptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command_PinOperation::set_has_pinoptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command_PinOperation::clear_has_pinoptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command_PinOperation::clear_pinoptype() {
  pinoptype_ = -1;
  clear_has_pinoptype();
}
inline ::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType Command_PinOperation::pinoptype() const {
  return static_cast< ::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType >(pinoptype_);
}
inline void Command_PinOperation::set_pinoptype(::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType value) {
  assert(::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType_IsValid(value));
  set_has_pinoptype();
  pinoptype_ = value;
}

// -------------------------------------------------------------------

// Command

// optional .com.seagate.kinetic.client.proto.Command.Header header = 1;
inline bool Command::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_header() {
  if (header_ != NULL) header_->::com::seagate::kinetic::client::proto::Command_Header::Clear();
  clear_has_header();
}
inline const ::com::seagate::kinetic::client::proto::Command_Header& Command::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::com::seagate::kinetic::client::proto::Command_Header* Command::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::com::seagate::kinetic::client::proto::Command_Header;
  return header_;
}
inline ::com::seagate::kinetic::client::proto::Command_Header* Command::release_header() {
  clear_has_header();
  ::com::seagate::kinetic::client::proto::Command_Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Command::set_allocated_header(::com::seagate::kinetic::client::proto::Command_Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Body body = 2;
inline bool Command::has_body() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_body() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_body() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_body() {
  if (body_ != NULL) body_->::com::seagate::kinetic::client::proto::Command_Body::Clear();
  clear_has_body();
}
inline const ::com::seagate::kinetic::client::proto::Command_Body& Command::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::com::seagate::kinetic::client::proto::Command_Body* Command::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::com::seagate::kinetic::client::proto::Command_Body;
  return body_;
}
inline ::com::seagate::kinetic::client::proto::Command_Body* Command::release_body() {
  clear_has_body();
  ::com::seagate::kinetic::client::proto::Command_Body* temp = body_;
  body_ = NULL;
  return temp;
}
inline void Command::set_allocated_body(::com::seagate::kinetic::client::proto::Command_Body* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}

// optional .com.seagate.kinetic.client.proto.Command.Status status = 3;
inline bool Command::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_status() {
  if (status_ != NULL) status_->::com::seagate::kinetic::client::proto::Command_Status::Clear();
  clear_has_status();
}
inline const ::com::seagate::kinetic::client::proto::Command_Status& Command::status() const {
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::com::seagate::kinetic::client::proto::Command_Status* Command::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::com::seagate::kinetic::client::proto::Command_Status;
  return status_;
}
inline ::com::seagate::kinetic::client::proto::Command_Status* Command::release_status() {
  clear_has_status();
  ::com::seagate::kinetic::client::proto::Command_Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Command::set_allocated_status(::com::seagate::kinetic::client::proto::Command_Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace client
}  // namespace kinetic
}  // namespace seagate
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Message_AuthType>() {
  return ::com::seagate::kinetic::client::proto::Message_AuthType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_Status_StatusCode>() {
  return ::com::seagate::kinetic::client::proto::Command_Status_StatusCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_GetLog_Type>() {
  return ::com::seagate::kinetic::client::proto::Command_GetLog_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm>() {
  return ::com::seagate::kinetic::client::proto::Command_Security_ACL_HMACAlgorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission>() {
  return ::com::seagate::kinetic::client::proto::Command_Security_ACL_Permission_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType>() {
  return ::com::seagate::kinetic::client::proto::Command_PinOperation_PinOpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_Synchronization>() {
  return ::com::seagate::kinetic::client::proto::Command_Synchronization_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_Priority>() {
  return ::com::seagate::kinetic::client::proto::Command_Priority_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_Algorithm>() {
  return ::com::seagate::kinetic::client::proto::Command_Algorithm_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::seagate::kinetic::client::proto::Command_MessageType>() {
  return ::com::seagate::kinetic::client::proto::Command_MessageType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_kinetic_5fclient_2eproto__INCLUDED
